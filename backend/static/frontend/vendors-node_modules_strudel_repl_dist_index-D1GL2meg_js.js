/*! For license information please see vendors-node_modules_strudel_repl_dist_index-D1GL2meg_js.js.LICENSE.txt */
"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([["vendors-node_modules_strudel_repl_dist_index-D1GL2meg_js"],{"../node_modules/@strudel/repl/dist/index-D1GL2meg.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebMidi: () => (/* binding */ c),\n/* harmony export */   defaultmidimap: () => (/* binding */ ye),\n/* harmony export */   enableWebMidi: () => (/* binding */ ee),\n/* harmony export */   midicontrolMap: () => (/* binding */ y),\n/* harmony export */   midimaps: () => (/* binding */ we),\n/* harmony export */   midin: () => (/* binding */ Se),\n/* harmony export */   midisoundMap: () => (/* binding */ _e)\n/* harmony export */ });\n/* harmony import */ var _index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-DfdLyHnT.js */ "../node_modules/@strudel/repl/dist/index-DfdLyHnT.js");\n\nclass E {\n  /**\n   * Creates a new `EventEmitter`object.\n   *\n   * @param {boolean} [eventsSuspended=false] Whether the `EventEmitter` is initially in a suspended\n   * state (i.e. not executing callbacks).\n   */\n  constructor(e = !1) {\n    this.eventMap = {}, this.eventsSuspended = e == !0;\n  }\n  /**\n   * The callback function is executed when the associated event is triggered via [`emit()`](#emit).\n   * The [`emit()`](#emit) method relays all additional arguments it received to the callback\n   * functions. Since [`emit()`](#emit) can be passed a variable number of arguments, it is up to\n   * the developer to make sure the arguments match those of the associated callback. In addition,\n   * the callback also separately receives all the arguments present in the listener\'s\n   * [`arguments`](Listener#arguments) property. This makes it easy to pass data from where the\n   * listener is added to where the listener is executed.\n   *\n   * @callback EventEmitter~callback\n   * @param {...*} [args] A variable number of arguments matching the ones (if any) that were passed\n   * to the [`emit()`](#emit) method (except, the first one) followed by the arguments found in the\n   * listener\'s [`arguments`](Listener#arguments) array.\n   */\n  /**\n   * Adds a listener for the specified event. It returns the [`Listener`]{@link Listener} object\n   * that was created and attached to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use\n   * [`EventEmitter.ANY_EVENT`]{@link #ANY_EVENT} as the first parameter. Note that a global\n   * listener will also be triggered by non-registered events.\n   *\n   * @param {string|Symbol} event The event to listen to.\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs.\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The value of `this` in the callback function.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array and thus executed first.\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {number} [options.remaining=Infinity] The number of times after which the callback\n   * should automatically be removed.\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the [`arguments`]{@link Listener#arguments}\n   * property of the [`Listener`]{@link Listener} object and can be retrieved or modified as\n   * desired.\n   *\n   * @returns {Listener} The newly created [`Listener`]{@link Listener} object.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.\n   * @throws {TypeError} The `callback` parameter must be a function.\n   */\n  addListener(e, t, n = {}) {\n    if (typeof e == "string" && e.length < 1 || e instanceof String && e.length < 1 || typeof e != "string" && !(e instanceof String) && e !== E.ANY_EVENT)\n      throw new TypeError("The \'event\' parameter must be a string or EventEmitter.ANY_EVENT.");\n    if (typeof t != "function") throw new TypeError("The callback must be a function.");\n    const r = new $(e, this, t, n);\n    return this.eventMap[e] || (this.eventMap[e] = []), n.prepend ? this.eventMap[e].unshift(r) : this.eventMap[e].push(r), r;\n  }\n  /**\n   * Adds a one-time listener for the specified event. The listener will be executed once and then\n   * destroyed. It returns the [`Listener`]{@link Listener} object that was created and attached\n   * to the event.\n   *\n   * To attach a global listener that will be triggered for any events, use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the first parameter. Note that a\n   * global listener will also be triggered by non-registered events.\n   *\n   * @param {string|Symbol} event The event to listen to\n   * @param {EventEmitter~callback} callback The callback function to execute when the event occurs\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=this] The context to invoke the callback function in.\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array and thus executed first.\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the [`arguments`]{@link Listener#arguments}\n   * property of the [`Listener`]{@link Listener} object and can be retrieved or modified as\n   * desired.\n   *\n   * @returns {Listener} The newly created [`Listener`]{@link Listener} object.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.\n   * @throws {TypeError} The `callback` parameter must be a function.\n   */\n  addOneTimeListener(e, t, n = {}) {\n    n.remaining = 1, this.addListener(e, t, n);\n  }\n  /**\n   * Identifier to use when adding or removing a listener that should be triggered when any events\n   * occur.\n   *\n   * @type {Symbol}\n   */\n  static get ANY_EVENT() {\n    return Symbol.for("Any event");\n  }\n  /**\n   * Returns `true` if the specified event has at least one registered listener. If no event is\n   * specified, the method returns `true` if any event has at least one listener registered (this\n   * includes global listeners registered to\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}).\n   *\n   * Note: to specifically check for global listeners added with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}, use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.\n   *\n   * @param {string|Symbol} [event=(any event)] The event to check\n   * @param {function|Listener} [callback=(any callback)] The actual function that was added to the\n   * event or the {@link Listener} object returned by `addListener()`.\n   * @returns {boolean}\n   */\n  hasListener(e, t) {\n    return e === void 0 ? this.eventMap[E.ANY_EVENT] && this.eventMap[E.ANY_EVENT].length > 0 ? !0 : Object.entries(this.eventMap).some(([, n]) => n.length > 0) : this.eventMap[e] && this.eventMap[e].length > 0 ? t instanceof $ ? this.eventMap[e].filter((r) => r === t).length > 0 : typeof t == "function" ? this.eventMap[e].filter((r) => r.callback === t).length > 0 : t == null : !1;\n  }\n  /**\n   * An array of all the unique event names for which the emitter has at least one registered\n   * listener.\n   *\n   * Note: this excludes global events registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} because they are not tied to a\n   * specific event.\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  get eventNames() {\n    return Object.keys(this.eventMap);\n  }\n  /**\n   * Returns an array of all the [`Listener`]{@link Listener} objects that have been registered for\n   * a specific event.\n   *\n   * Please note that global events (those added with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}) are not returned for "regular"\n   * events. To get the list of global listeners, specifically use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.\n   *\n   * @param {string|Symbol} event The event to get listeners for.\n   * @returns {Listener[]} An array of [`Listener`]{@link Listener} objects.\n   */\n  getListeners(e) {\n    return this.eventMap[e] || [];\n  }\n  /**\n   * Suspends execution of all callbacks functions registered for the specified event type.\n   *\n   * You can suspend execution of callbacks registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} by passing\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} to `suspendEvent()`. Beware that this\n   * will not suspend all callbacks but only those registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}. While this may seem counter-intuitive\n   * at first glance, it allows the selective suspension of global listeners while leaving other\n   * listeners alone. If you truly want to suspends all callbacks for a specific\n   * [`EventEmitter`]{@link EventEmitter}, simply set its `eventsSuspended` property to `true`.\n   *\n   * @param {string|Symbol} event The event name (or `EventEmitter.ANY_EVENT`) for which to suspend\n   * execution of all callback functions.\n   */\n  suspendEvent(e) {\n    this.getListeners(e).forEach((t) => {\n      t.suspended = !0;\n    });\n  }\n  /**\n   * Resumes execution of all suspended callback functions registered for the specified event type.\n   *\n   * You can resume execution of callbacks registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} by passing\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} to `unsuspendEvent()`. Beware that\n   * this will not resume all callbacks but only those registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}. While this may seem\n   * counter-intuitive, it allows the selective unsuspension of global listeners while leaving other\n   * callbacks alone.\n   *\n   * @param {string|Symbol} event The event name (or `EventEmitter.ANY_EVENT`) for which to resume\n   * execution of all callback functions.\n   */\n  unsuspendEvent(e) {\n    this.getListeners(e).forEach((t) => {\n      t.suspended = !1;\n    });\n  }\n  /**\n   * Returns the number of listeners registered for a specific event.\n   *\n   * Please note that global events (those added with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}) do not count towards the remaining\n   * number for a "regular" event. To get the number of global listeners, specifically use\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the parameter.\n   *\n   * @param {string|Symbol} event The event which is usually a string but can also be the special\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} symbol.\n   * @returns {number} An integer representing the number of listeners registered for the specified\n   * event.\n   */\n  getListenerCount(e) {\n    return this.getListeners(e).length;\n  }\n  /**\n   * Executes the callback function of all the [`Listener`]{@link Listener} objects registered for\n   * a given event. The callback functions are passed the additional arguments passed to `emit()`\n   * (if any) followed by the arguments present in the [`arguments`](Listener#arguments) property of\n   * the [`Listener`](Listener) object (if any).\n   *\n   * If the [`eventsSuspended`]{@link #eventsSuspended} property is `true` or the\n   * [`Listener.suspended`]{@link Listener#suspended} property is `true`, the callback functions\n   * will not be executed.\n   *\n   * This function returns an array containing the return values of each of the callbacks.\n   *\n   * It should be noted that the regular listeners are triggered first followed by the global\n   * listeners (those added with [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}).\n   *\n   * @param {string} event The event\n   * @param {...*} args Arbitrary number of arguments to pass along to the callback functions\n   *\n   * @returns {Array} An array containing the return value of each of the executed listener\n   * functions.\n   *\n   * @throws {TypeError} The `event` parameter must be a string.\n   */\n  emit(e, ...t) {\n    if (typeof e != "string" && !(e instanceof String))\n      throw new TypeError("The \'event\' parameter must be a string.");\n    if (this.eventsSuspended) return;\n    let n = [], r = this.eventMap[E.ANY_EVENT] || [];\n    return this.eventMap[e] && (r = r.concat(this.eventMap[e])), r.forEach((s) => {\n      if (s.suspended) return;\n      let d = [...t];\n      Array.isArray(s.arguments) && (d = d.concat(s.arguments)), s.remaining > 0 && (n.push(s.callback.apply(s.context, d)), s.count++), --s.remaining < 1 && s.remove();\n    }), n;\n  }\n  /**\n   * Removes all the listeners that were added to the object upon which the method is called and\n   * that match the specified criterias. If no parameters are passed, all listeners added to this\n   * object will be removed. If only the `event` parameter is passed, all listeners for that event\n   * will be removed from that object. You can remove global listeners by using\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} as the first parameter.\n   *\n   * To use more granular options, you must at least define the `event`. Then, you can specify the\n   * callback to match or one or more of the additional options.\n   *\n   * @param {string} [event] The event name.\n   * @param {EventEmitter~callback} [callback] Only remove the listeners that match this exact\n   * callback function.\n   * @param {Object} [options]\n   * @param {*} [options.context] Only remove the listeners that have this exact context.\n   * @param {number} [options.remaining] Only remove the listener if it has exactly that many\n   * remaining times to be executed.\n   */\n  removeListener(e, t, n = {}) {\n    if (e === void 0) {\n      this.eventMap = {};\n      return;\n    } else if (!this.eventMap[e])\n      return;\n    let r = this.eventMap[e].filter((s) => t && s.callback !== t || n.remaining && n.remaining !== s.remaining || n.context && n.context !== s.context);\n    r.length ? this.eventMap[e] = r : delete this.eventMap[e];\n  }\n  /**\n   * The `waitFor()` method is an async function which returns a promise. The promise is fulfilled\n   * when the specified event occurs. The event can be a regular event or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} (if you want to resolve as soon as any\n   * event is emitted).\n   *\n   * If the `duration` option is set, the promise will only be fulfilled if the event is emitted\n   * within the specified duration. If the event has not been fulfilled after the specified\n   * duration, the promise is rejected. This makes it super easy to wait for an event and timeout\n   * after a certain time if the event is not triggered.\n   *\n   * @param {string|Symbol} event The event to wait for\n   * @param {Object} [options={}]\n   * @param {number} [options.duration=Infinity] The number of milliseconds to wait before the\n   * promise is automatically rejected.\n   */\n  async waitFor(e, t = {}) {\n    return t.duration = parseInt(t.duration), (isNaN(t.duration) || t.duration <= 0) && (t.duration = 1 / 0), new Promise((n, r) => {\n      let s, d = this.addListener(e, () => {\n        clearTimeout(s), n();\n      }, { remaining: 1 });\n      t.duration !== 1 / 0 && (s = setTimeout(() => {\n        d.remove(), r("The duration expired before the event was emitted.");\n      }, t.duration));\n    });\n  }\n  /**\n   * The number of unique events that have registered listeners.\n   *\n   * Note: this excludes global events registered with\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT} because they are not tied to a\n   * specific event.\n   *\n   * @type {number}\n   * @readonly\n   */\n  get eventCount() {\n    return Object.keys(this.eventMap).length;\n  }\n}\nclass $ {\n  /**\n   * Creates a new `Listener` object\n   *\n   * @param {string|Symbol} event The event being listened to\n   * @param {EventEmitter} target The [`EventEmitter`]{@link EventEmitter} object that the listener\n   * is attached to.\n   * @param {EventEmitter~callback} callback The function to call when the listener is triggered\n   * @param {Object} [options={}]\n   * @param {Object} [options.context=target] The context to invoke the listener in (a.k.a. the\n   * value of `this` inside the callback function).\n   * @param {number} [options.remaining=Infinity] The remaining number of times after which the\n   * callback should automatically be removed.\n   * @param {array} [options.arguments] An array of arguments that will be passed separately to the\n   * callback function upon execution. The array is stored in the [`arguments`]{@link #arguments}\n   * property and can be retrieved or modified as desired.\n   *\n   * @throws {TypeError} The `event` parameter must be a string or\n   * [`EventEmitter.ANY_EVENT`]{@link EventEmitter#ANY_EVENT}.\n   * @throws {ReferenceError} The `target` parameter is mandatory.\n   * @throws {TypeError} The `callback` must be a function.\n   */\n  constructor(e, t, n, r = {}) {\n    if (typeof e != "string" && !(e instanceof String) && e !== E.ANY_EVENT)\n      throw new TypeError("The \'event\' parameter must be a string or EventEmitter.ANY_EVENT.");\n    if (!t)\n      throw new ReferenceError("The \'target\' parameter is mandatory.");\n    if (typeof n != "function")\n      throw new TypeError("The \'callback\' must be a function.");\n    r.arguments !== void 0 && !Array.isArray(r.arguments) && (r.arguments = [r.arguments]), r = Object.assign({\n      context: t,\n      remaining: 1 / 0,\n      arguments: void 0,\n      duration: 1 / 0\n    }, r), r.duration !== 1 / 0 && setTimeout(() => this.remove(), r.duration), this.arguments = r.arguments, this.callback = n, this.context = r.context, this.count = 0, this.event = e, this.remaining = parseInt(r.remaining) >= 1 ? parseInt(r.remaining) : 1 / 0, this.suspended = !1, this.target = t;\n  }\n  /**\n   * Removes the listener from its target.\n   */\n  remove() {\n    this.target.removeListener(\n      this.event,\n      this.callback,\n      { context: this.context, remaining: this.remaining }\n    );\n  }\n}\n/**\n * The `Enumerations` class contains enumerations and arrays of elements used throughout the\n * library. All its properties are static and should be referenced using the class name. For\n * example: `Enumerations.CHANNEL_MESSAGES`.\n *\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass i {\n  /**\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @deprecated since 3.1 (use Enumerations.CHANNEL_MESSAGES instead)\n   * @private\n   * @static\n   */\n  static get MIDI_CHANNEL_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_CHANNEL_MESSAGES enum has been deprecated. Use the Enumerations.CHANNEL_MESSAGES enum instead."\n    ), i.CHANNEL_MESSAGES;\n  }\n  /**\n   * Enumeration of all MIDI channel message names and their associated 4-bit numerical value:\n   *\n   * | Message Name        | Hexadecimal | Decimal |\n   * |---------------------|-------------|---------|\n   * | `noteoff`           | 0x8         | 8       |\n   * | `noteon`            | 0x9         | 9       |\n   * | `keyaftertouch`     | 0xA         | 10      |\n   * | `controlchange`     | 0xB         | 11      |\n   * | `programchange`     | 0xC         | 12      |\n   * | `channelaftertouch` | 0xD         | 13      |\n   * | `pitchbend`         | 0xE         | 14      |\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @since 3.1\n   * @static\n   */\n  static get CHANNEL_MESSAGES() {\n    return {\n      noteoff: 8,\n      // 8\n      noteon: 9,\n      // 9\n      keyaftertouch: 10,\n      // 10\n      controlchange: 11,\n      // 11\n      programchange: 12,\n      // 12\n      channelaftertouch: 13,\n      // 13\n      pitchbend: 14\n      // 14\n    };\n  }\n  /**\n   * A simple array of the 16 valid MIDI channel numbers (`1` to `16`):\n   *\n   * @type {number[]}\n   * @readonly\n   * @since 3.1\n   * @static\n   */\n  static get CHANNEL_NUMBERS() {\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  }\n  /**\n   * @type {number[]}\n   * @readonly\n   * @deprecated since 3.1 (use Enumerations.CHANNEL_NUMBERS instead)\n   * @private\n   * @static\n   */\n  static get MIDI_CHANNEL_NUMBERS() {\n    return this.validation && console.warn(\n      "The MIDI_CHANNEL_NUMBERS array has been deprecated. Use the Enumerations.CHANNEL_NUMBERS array instead."\n    ), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];\n  }\n  /**\n   * Enumeration of all MIDI channel mode message names and their associated numerical value:\n   *\n   *\n   * | Message Name          | Hexadecimal | Decimal |\n   * |-----------------------|-------------|---------|\n   * | `allsoundoff`         | 0x78        | 120     |\n   * | `resetallcontrollers` | 0x79        | 121     |\n   * | `localcontrol`        | 0x7A        | 122     |\n   * | `allnotesoff`         | 0x7B        | 123     |\n   * | `omnimodeoff`         | 0x7C        | 124     |\n   * | `omnimodeon`          | 0x7D        | 125     |\n   * | `monomodeon`          | 0x7E        | 126     |\n   * | `polymodeon`          | 0x7F        | 127     |\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @since 3.1\n   * @static\n   */\n  static get CHANNEL_MODE_MESSAGES() {\n    return {\n      allsoundoff: 120,\n      resetallcontrollers: 121,\n      localcontrol: 122,\n      allnotesoff: 123,\n      omnimodeoff: 124,\n      omnimodeon: 125,\n      monomodeon: 126,\n      polymodeon: 127\n    };\n  }\n  /**\n   * @enum {Object.<string, number>}\n   * @deprecated since 3.1 (use Enumerations.CHANNEL_MODE_MESSAGES instead)\n   * @private\n   * @readonly\n   * @static\n   */\n  static get MIDI_CHANNEL_MODE_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_CHANNEL_MODE_MESSAGES enum has been deprecated. Use the Enumerations.CHANNEL_MODE_MESSAGES enum instead."\n    ), i.CHANNEL_MODE_MESSAGES;\n  }\n  /**\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @static\n   * @private\n   * @deprecated since version 3.0.26 (use `CONTROL_CHANGE_MESSAGES` instead)\n   */\n  static get MIDI_CONTROL_CHANGE_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_CONTROL_CHANGE_MESSAGES enum has been deprecated. Use the Enumerations.CONTROL_CHANGE_MESSAGES array instead."\n    ), {\n      bankselectcoarse: 0,\n      modulationwheelcoarse: 1,\n      breathcontrollercoarse: 2,\n      controller3: 3,\n      footcontrollercoarse: 4,\n      portamentotimecoarse: 5,\n      dataentrycoarse: 6,\n      volumecoarse: 7,\n      balancecoarse: 8,\n      controller9: 9,\n      pancoarse: 10,\n      expressioncoarse: 11,\n      effectcontrol1coarse: 12,\n      effectcontrol2coarse: 13,\n      controller14: 14,\n      controller15: 15,\n      generalpurposeslider1: 16,\n      generalpurposeslider2: 17,\n      generalpurposeslider3: 18,\n      generalpurposeslider4: 19,\n      controller20: 20,\n      controller21: 21,\n      controller22: 22,\n      controller23: 23,\n      controller24: 24,\n      controller25: 25,\n      controller26: 26,\n      controller27: 27,\n      controller28: 28,\n      controller29: 29,\n      controller30: 30,\n      controller31: 31,\n      bankselectfine: 32,\n      modulationwheelfine: 33,\n      breathcontrollerfine: 34,\n      controller35: 35,\n      footcontrollerfine: 36,\n      portamentotimefine: 37,\n      dataentryfine: 38,\n      volumefine: 39,\n      balancefine: 40,\n      controller41: 41,\n      panfine: 42,\n      expressionfine: 43,\n      effectcontrol1fine: 44,\n      effectcontrol2fine: 45,\n      controller46: 46,\n      controller47: 47,\n      controller48: 48,\n      controller49: 49,\n      controller50: 50,\n      controller51: 51,\n      controller52: 52,\n      controller53: 53,\n      controller54: 54,\n      controller55: 55,\n      controller56: 56,\n      controller57: 57,\n      controller58: 58,\n      controller59: 59,\n      controller60: 60,\n      controller61: 61,\n      controller62: 62,\n      controller63: 63,\n      holdpedal: 64,\n      portamento: 65,\n      sustenutopedal: 66,\n      softpedal: 67,\n      legatopedal: 68,\n      hold2pedal: 69,\n      soundvariation: 70,\n      resonance: 71,\n      soundreleasetime: 72,\n      soundattacktime: 73,\n      brightness: 74,\n      soundcontrol6: 75,\n      soundcontrol7: 76,\n      soundcontrol8: 77,\n      soundcontrol9: 78,\n      soundcontrol10: 79,\n      generalpurposebutton1: 80,\n      generalpurposebutton2: 81,\n      generalpurposebutton3: 82,\n      generalpurposebutton4: 83,\n      controller84: 84,\n      controller85: 85,\n      controller86: 86,\n      controller87: 87,\n      controller88: 88,\n      controller89: 89,\n      controller90: 90,\n      reverblevel: 91,\n      tremololevel: 92,\n      choruslevel: 93,\n      celestelevel: 94,\n      phaserlevel: 95,\n      databuttonincrement: 96,\n      databuttondecrement: 97,\n      nonregisteredparametercoarse: 98,\n      nonregisteredparameterfine: 99,\n      registeredparametercoarse: 100,\n      registeredparameterfine: 101,\n      controller102: 102,\n      controller103: 103,\n      controller104: 104,\n      controller105: 105,\n      controller106: 106,\n      controller107: 107,\n      controller108: 108,\n      controller109: 109,\n      controller110: 110,\n      controller111: 111,\n      controller112: 112,\n      controller113: 113,\n      controller114: 114,\n      controller115: 115,\n      controller116: 116,\n      controller117: 117,\n      controller118: 118,\n      controller119: 119,\n      allsoundoff: 120,\n      resetallcontrollers: 121,\n      localcontrol: 122,\n      allnotesoff: 123,\n      omnimodeoff: 124,\n      omnimodeon: 125,\n      monomodeon: 126,\n      polymodeon: 127\n    };\n  }\n  /**\n   * An array of objects, ordered by control number, describing control change messages. Each object\n   * in the array has 3 properties with some objects having a fourth one (`position`) :\n   *\n   *  * `number`: MIDI control number (0-127);\n   *  * `name`: name of emitted event (eg: `bankselectcoarse`, `choruslevel`, etc) that can be\n   *  listened to;\n   *  * `description`: user-friendly description of the controller\'s purpose;\n   *  * `position` (optional): whether this controller\'s value should be considered an `msb` or\n   *  `lsb`\n   *\n   * Not all controllers have a predefined function. For those that don\'t, `name` is the word\n   * "controller" followed by the number (e.g. `controller112`).\n   *\n   * | Event name                     | Control Number |\n   * |--------------------------------|----------------|\n   * | `bankselectcoarse`             | 0              |\n   * | `modulationwheelcoarse`        | 1              |\n   * | `breathcontrollercoarse`       | 2              |\n   * | `controller3`                  | 3              |\n   * | `footcontrollercoarse`         | 4              |\n   * | `portamentotimecoarse`         | 5              |\n   * | `dataentrycoarse`              | 6              |\n   * | `volumecoarse`                 | 7              |\n   * | `balancecoarse`                | 8              |\n   * | `controller9`                  | 9              |\n   * | `pancoarse`                    | 10             |\n   * | `expressioncoarse`             | 11             |\n   * | `effectcontrol1coarse`         | 12             |\n   * | `effectcontrol2coarse`         | 13             |\n   * | `controller14`                 | 14             |\n   * | `controller15`                 | 15             |\n   * | `generalpurposecontroller1`    | 16             |\n   * | `generalpurposecontroller2`    | 17             |\n   * | `generalpurposecontroller3`    | 18             |\n   * | `generalpurposecontroller4`    | 19             |\n   * | `controller20`                 | 20             |\n   * | `controller21`                 | 21             |\n   * | `controller22`                 | 22             |\n   * | `controller23`                 | 23             |\n   * | `controller24`                 | 24             |\n   * | `controller25`                 | 25             |\n   * | `controller26`                 | 26             |\n   * | `controller27`                 | 27             |\n   * | `controller28`                 | 28             |\n   * | `controller29`                 | 29             |\n   * | `controller30`                 | 30             |\n   * | `controller31`                 | 31             |\n   * | `bankselectfine`               | 32             |\n   * | `modulationwheelfine`          | 33             |\n   * | `breathcontrollerfine`         | 34             |\n   * | `controller35`                 | 35             |\n   * | `footcontrollerfine`           | 36             |\n   * | `portamentotimefine`           | 37             |\n   * | `dataentryfine`                | 38             |\n   * | `channelvolumefine`            | 39             |\n   * | `balancefine`                  | 40             |\n   * | `controller41`                 | 41             |\n   * | `panfine`                      | 42             |\n   * | `expressionfine`               | 43             |\n   * | `effectcontrol1fine`           | 44             |\n   * | `effectcontrol2fine`           | 45             |\n   * | `controller46`                 | 46             |\n   * | `controller47`                 | 47             |\n   * | `controller48`                 | 48             |\n   * | `controller49`                 | 49             |\n   * | `controller50`                 | 50             |\n   * | `controller51`                 | 51             |\n   * | `controller52`                 | 52             |\n   * | `controller53`                 | 53             |\n   * | `controller54`                 | 54             |\n   * | `controller55`                 | 55             |\n   * | `controller56`                 | 56             |\n   * | `controller57`                 | 57             |\n   * | `controller58`                 | 58             |\n   * | `controller59`                 | 59             |\n   * | `controller60`                 | 60             |\n   * | `controller61`                 | 61             |\n   * | `controller62`                 | 62             |\n   * | `controller63`                 | 63             |\n   * | `damperpedal`                  | 64             |\n   * | `portamento`                   | 65             |\n   * | `sostenuto`                    | 66             |\n   * | `softpedal`                    | 67             |\n   * | `legatopedal`                  | 68             |\n   * | `hold2`                        | 69             |\n   * | `soundvariation`               | 70             |\n   * | `resonance`                    | 71             |\n   * | `releasetime`                  | 72             |\n   * | `attacktime`                   | 73             |\n   * | `brightness`                   | 74             |\n   * | `decaytime`                    | 75             |\n   * | `vibratorate`                  | 76             |\n   * | `vibratodepth`                 | 77             |\n   * | `vibratodelay`                 | 78             |\n   * | `controller79`                 | 79             |\n   * | `generalpurposecontroller5`    | 80             |\n   * | `generalpurposecontroller6`    | 81             |\n   * | `generalpurposecontroller7`    | 82             |\n   * | `generalpurposecontroller8`    | 83             |\n   * | `portamentocontrol`            | 84             |\n   * | `controller85`                 | 85             |\n   * | `controller86`                 | 86             |\n   * | `controller87`                 | 87             |\n   * | `highresolutionvelocityprefix` | 88             |\n   * | `controller89`                 | 89             |\n   * | `controller90`                 | 90             |\n   * | `effect1depth`                 | 91             |\n   * | `effect2depth`                 | 92             |\n   * | `effect3depth`                 | 93             |\n   * | `effect4depth`                 | 94             |\n   * | `effect5depth`                 | 95             |\n   * | `dataincrement`                | 96             |\n   * | `datadecrement`                | 97             |\n   * | `nonregisteredparameterfine`   | 98             |\n   * | `nonregisteredparametercoarse` | 99             |\n   * | `nonregisteredparameterfine`   | 100            |\n   * | `registeredparametercoarse`    | 101            |\n   * | `controller102`                | 102            |\n   * | `controller103`                | 103            |\n   * | `controller104`                | 104            |\n   * | `controller105`                | 105            |\n   * | `controller106`                | 106            |\n   * | `controller107`                | 107            |\n   * | `controller108`                | 108            |\n   * | `controller109`                | 109            |\n   * | `controller110`                | 110            |\n   * | `controller111`                | 111            |\n   * | `controller112`                | 112            |\n   * | `controller113`                | 113            |\n   * | `controller114`                | 114            |\n   * | `controller115`                | 115            |\n   * | `controller116`                | 116            |\n   * | `controller117`                | 117            |\n   * | `controller118`                | 118            |\n   * | `controller119`                | 119            |\n   * | `allsoundoff`                  | 120            |\n   * | `resetallcontrollers`          | 121            |\n   * | `localcontrol`                 | 122            |\n   * | `allnotesoff`                  | 123            |\n   * | `omnimodeoff`                  | 124            |\n   * | `omnimodeon`                   | 125            |\n   * | `monomodeon`                   | 126            |\n   * | `polymodeon`                   | 127            |\n   *\n   * @type {object[]}\n   * @readonly\n   * @static\n   * @since 3.1\n   */\n  static get CONTROL_CHANGE_MESSAGES() {\n    return [\n      {\n        number: 0,\n        name: "bankselectcoarse",\n        description: "Bank Select (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 1,\n        name: "modulationwheelcoarse",\n        description: "Modulation Wheel (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 2,\n        name: "breathcontrollercoarse",\n        description: "Breath Controller (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 3,\n        name: "controller3",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 4,\n        name: "footcontrollercoarse",\n        description: "Foot Controller (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 5,\n        name: "portamentotimecoarse",\n        description: "Portamento Time (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 6,\n        name: "dataentrycoarse",\n        description: "Data Entry (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 7,\n        name: "volumecoarse",\n        description: "Channel Volume (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 8,\n        name: "balancecoarse",\n        description: "Balance (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 9,\n        name: "controller9",\n        description: "Controller 9 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 10,\n        name: "pancoarse",\n        description: "Pan (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 11,\n        name: "expressioncoarse",\n        description: "Expression Controller (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 12,\n        name: "effectcontrol1coarse",\n        description: "Effect Control 1 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 13,\n        name: "effectcontrol2coarse",\n        description: "Effect Control 2 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 14,\n        name: "controller14",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 15,\n        name: "controller15",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 16,\n        name: "generalpurposecontroller1",\n        description: "General Purpose Controller 1 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 17,\n        name: "generalpurposecontroller2",\n        description: "General Purpose Controller 2 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 18,\n        name: "generalpurposecontroller3",\n        description: "General Purpose Controller 3 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 19,\n        name: "generalpurposecontroller4",\n        description: "General Purpose Controller 4 (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 20,\n        name: "controller20",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 21,\n        name: "controller21",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 22,\n        name: "controller22",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 23,\n        name: "controller23",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 24,\n        name: "controller24",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 25,\n        name: "controller25",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 26,\n        name: "controller26",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 27,\n        name: "controller27",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 28,\n        name: "controller28",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 29,\n        name: "controller29",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 30,\n        name: "controller30",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 31,\n        name: "controller31",\n        description: "Undefined",\n        position: "msb"\n      },\n      {\n        number: 32,\n        name: "bankselectfine",\n        description: "Bank Select (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 33,\n        name: "modulationwheelfine",\n        description: "Modulation Wheel (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 34,\n        name: "breathcontrollerfine",\n        description: "Breath Controller (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 35,\n        name: "controller35",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 36,\n        name: "footcontrollerfine",\n        description: "Foot Controller (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 37,\n        name: "portamentotimefine",\n        description: "Portamento Time (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 38,\n        name: "dataentryfine",\n        description: "Data Entry (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 39,\n        name: "channelvolumefine",\n        description: "Channel Volume (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 40,\n        name: "balancefine",\n        description: "Balance (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 41,\n        name: "controller41",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 42,\n        name: "panfine",\n        description: "Pan (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 43,\n        name: "expressionfine",\n        description: "Expression Controller (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 44,\n        name: "effectcontrol1fine",\n        description: "Effect control 1 (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 45,\n        name: "effectcontrol2fine",\n        description: "Effect control 2 (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 46,\n        name: "controller46",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 47,\n        name: "controller47",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 48,\n        name: "controller48",\n        description: "General Purpose Controller 1 (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 49,\n        name: "controller49",\n        description: "General Purpose Controller 2 (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 50,\n        name: "controller50",\n        description: "General Purpose Controller 3 (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 51,\n        name: "controller51",\n        description: "General Purpose Controller 4 (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 52,\n        name: "controller52",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 53,\n        name: "controller53",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 54,\n        name: "controller54",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 55,\n        name: "controller55",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 56,\n        name: "controller56",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 57,\n        name: "controller57",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 58,\n        name: "controller58",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 59,\n        name: "controller59",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 60,\n        name: "controller60",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 61,\n        name: "controller61",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 62,\n        name: "controller62",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 63,\n        name: "controller63",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 64,\n        name: "damperpedal",\n        description: "Damper Pedal On/Off"\n      },\n      {\n        number: 65,\n        name: "portamento",\n        description: "Portamento On/Off"\n      },\n      {\n        number: 66,\n        name: "sostenuto",\n        description: "Sostenuto On/Off"\n      },\n      {\n        number: 67,\n        name: "softpedal",\n        description: "Soft Pedal On/Off"\n      },\n      {\n        number: 68,\n        name: "legatopedal",\n        description: "Legato Pedal On/Off"\n      },\n      {\n        number: 69,\n        name: "hold2",\n        description: "Hold 2 On/Off"\n      },\n      {\n        number: 70,\n        name: "soundvariation",\n        description: "Sound Variation",\n        position: "lsb"\n      },\n      {\n        number: 71,\n        name: "resonance",\n        description: "Resonance",\n        position: "lsb"\n      },\n      {\n        number: 72,\n        name: "releasetime",\n        description: "Release Time",\n        position: "lsb"\n      },\n      {\n        number: 73,\n        name: "attacktime",\n        description: "Attack Time",\n        position: "lsb"\n      },\n      {\n        number: 74,\n        name: "brightness",\n        description: "Brightness",\n        position: "lsb"\n      },\n      {\n        number: 75,\n        name: "decaytime",\n        description: "Decay Time",\n        position: "lsb"\n      },\n      {\n        number: 76,\n        name: "vibratorate",\n        description: "Vibrato Rate",\n        position: "lsb"\n      },\n      {\n        number: 77,\n        name: "vibratodepth",\n        description: "Vibrato Depth",\n        position: "lsb"\n      },\n      {\n        number: 78,\n        name: "vibratodelay",\n        description: "Vibrato Delay",\n        position: "lsb"\n      },\n      {\n        number: 79,\n        name: "controller79",\n        description: "Undefined",\n        position: "lsb"\n      },\n      {\n        number: 80,\n        name: "generalpurposecontroller5",\n        description: "General Purpose Controller 5",\n        position: "lsb"\n      },\n      {\n        number: 81,\n        name: "generalpurposecontroller6",\n        description: "General Purpose Controller 6",\n        position: "lsb"\n      },\n      {\n        number: 82,\n        name: "generalpurposecontroller7",\n        description: "General Purpose Controller 7",\n        position: "lsb"\n      },\n      {\n        number: 83,\n        name: "generalpurposecontroller8",\n        description: "General Purpose Controller 8",\n        position: "lsb"\n      },\n      {\n        number: 84,\n        name: "portamentocontrol",\n        description: "Portamento Control",\n        position: "lsb"\n      },\n      {\n        number: 85,\n        name: "controller85",\n        description: "Undefined"\n      },\n      {\n        number: 86,\n        name: "controller86",\n        description: "Undefined"\n      },\n      {\n        number: 87,\n        name: "controller87",\n        description: "Undefined"\n      },\n      {\n        number: 88,\n        name: "highresolutionvelocityprefix",\n        description: "High Resolution Velocity Prefix",\n        position: "lsb"\n      },\n      {\n        number: 89,\n        name: "controller89",\n        description: "Undefined"\n      },\n      {\n        number: 90,\n        name: "controller90",\n        description: "Undefined"\n      },\n      {\n        number: 91,\n        name: "effect1depth",\n        description: "Effects 1 Depth (Reverb Send Level)"\n      },\n      {\n        number: 92,\n        name: "effect2depth",\n        description: "Effects 2 Depth"\n      },\n      {\n        number: 93,\n        name: "effect3depth",\n        description: "Effects 3 Depth (Chorus Send Level)"\n      },\n      {\n        number: 94,\n        name: "effect4depth",\n        description: "Effects 4 Depth"\n      },\n      {\n        number: 95,\n        name: "effect5depth",\n        description: "Effects 5 Depth"\n      },\n      {\n        number: 96,\n        name: "dataincrement",\n        description: "Data Increment"\n      },\n      {\n        number: 97,\n        name: "datadecrement",\n        description: "Data Decrement"\n      },\n      {\n        number: 98,\n        name: "nonregisteredparameterfine",\n        description: "Non-Registered Parameter Number (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 99,\n        name: "nonregisteredparametercoarse",\n        description: "Non-Registered Parameter Number (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 100,\n        name: "registeredparameterfine",\n        description: "Registered Parameter Number (Fine)",\n        position: "lsb"\n      },\n      {\n        number: 101,\n        name: "registeredparametercoarse",\n        description: "Registered Parameter Number (Coarse)",\n        position: "msb"\n      },\n      {\n        number: 102,\n        name: "controller102",\n        description: "Undefined"\n      },\n      {\n        number: 103,\n        name: "controller103",\n        description: "Undefined"\n      },\n      {\n        number: 104,\n        name: "controller104",\n        description: "Undefined"\n      },\n      {\n        number: 105,\n        name: "controller105",\n        description: "Undefined"\n      },\n      {\n        number: 106,\n        name: "controller106",\n        description: "Undefined"\n      },\n      {\n        number: 107,\n        name: "controller107",\n        description: "Undefined"\n      },\n      {\n        number: 108,\n        name: "controller108",\n        description: "Undefined"\n      },\n      {\n        number: 109,\n        name: "controller109",\n        description: "Undefined"\n      },\n      {\n        number: 110,\n        name: "controller110",\n        description: "Undefined"\n      },\n      {\n        number: 111,\n        name: "controller111",\n        description: "Undefined"\n      },\n      {\n        number: 112,\n        name: "controller112",\n        description: "Undefined"\n      },\n      {\n        number: 113,\n        name: "controller113",\n        description: "Undefined"\n      },\n      {\n        number: 114,\n        name: "controller114",\n        description: "Undefined"\n      },\n      {\n        number: 115,\n        name: "controller115",\n        description: "Undefined"\n      },\n      {\n        number: 116,\n        name: "controller116",\n        description: "Undefined"\n      },\n      {\n        number: 117,\n        name: "controller117",\n        description: "Undefined"\n      },\n      {\n        number: 118,\n        name: "controller118",\n        description: "Undefined"\n      },\n      {\n        number: 119,\n        name: "controller119",\n        description: "Undefined"\n      },\n      {\n        number: 120,\n        name: "allsoundoff",\n        description: "All Sound Off"\n      },\n      {\n        number: 121,\n        name: "resetallcontrollers",\n        description: "Reset All Controllers"\n      },\n      {\n        number: 122,\n        name: "localcontrol",\n        description: "Local Control On/Off"\n      },\n      {\n        number: 123,\n        name: "allnotesoff",\n        description: "All Notes Off"\n      },\n      {\n        number: 124,\n        name: "omnimodeoff",\n        description: "Omni Mode Off"\n      },\n      {\n        number: 125,\n        name: "omnimodeon",\n        description: "Omni Mode On"\n      },\n      {\n        number: 126,\n        name: "monomodeon",\n        description: "Mono Mode On"\n      },\n      {\n        number: 127,\n        name: "polymodeon",\n        description: "Poly Mode On"\n      }\n    ];\n  }\n  /**\n   * Enumeration of all MIDI registered parameters and their associated pair of numerical values.\n   * MIDI registered parameters extend the original list of control change messages. Currently,\n   * there are only a limited number of them:\n   *\n   *\n   * | Control Function             | [LSB, MSB]   |\n   * |------------------------------|--------------|\n   * | `pitchbendrange`             | [0x00, 0x00] |\n   * | `channelfinetuning`          | [0x00, 0x01] |\n   * | `channelcoarsetuning`        | [0x00, 0x02] |\n   * | `tuningprogram`              | [0x00, 0x03] |\n   * | `tuningbank`                 | [0x00, 0x04] |\n   * | `modulationrange`            | [0x00, 0x05] |\n   * | `azimuthangle`               | [0x3D, 0x00] |\n   * | `elevationangle`             | [0x3D, 0x01] |\n   * | `gain`                       | [0x3D, 0x02] |\n   * | `distanceratio`              | [0x3D, 0x03] |\n   * | `maximumdistance`            | [0x3D, 0x04] |\n   * | `maximumdistancegain`        | [0x3D, 0x05] |\n   * | `referencedistanceratio`     | [0x3D, 0x06] |\n   * | `panspreadangle`             | [0x3D, 0x07] |\n   * | `rollangle`                  | [0x3D, 0x08] |\n   *\n   * @enum {Object.<string, number[]>}\n   * @readonly\n   * @since 3.1\n   * @static\n   */\n  static get REGISTERED_PARAMETERS() {\n    return {\n      pitchbendrange: [0, 0],\n      channelfinetuning: [0, 1],\n      channelcoarsetuning: [0, 2],\n      tuningprogram: [0, 3],\n      tuningbank: [0, 4],\n      modulationrange: [0, 5],\n      azimuthangle: [61, 0],\n      elevationangle: [61, 1],\n      gain: [61, 2],\n      distanceratio: [61, 3],\n      maximumdistance: [61, 4],\n      maximumdistancegain: [61, 5],\n      referencedistanceratio: [61, 6],\n      panspreadangle: [61, 7],\n      rollangle: [61, 8]\n    };\n  }\n  /**\n   * @enum {Object.<string, number[]>}\n   * @readonly\n   * @deprecated since 3.1 (use Enumerations.REGISTERED_PARAMETERS instead)\n   * @private\n   * @static\n   */\n  static get MIDI_REGISTERED_PARAMETERS() {\n    return this.validation && console.warn(\n      "The MIDI_REGISTERED_PARAMETERS enum has been deprecated. Use the Enumerations.REGISTERED_PARAMETERS enum instead."\n    ), i.MIDI_REGISTERED_PARAMETERS;\n  }\n  /**\n   * Enumeration of all valid MIDI system messages and matching numerical values. This library also\n   * uses two additional custom messages.\n   *\n   * **System Common Messages**\n   *\n   * | Function               | Hexadecimal | Decimal |\n   * |------------------------|-------------|---------|\n   * | `sysex`                | 0xF0        |  240    |\n   * | `timecode`             | 0xF1        |  241    |\n   * | `songposition`         | 0xF2        |  242    |\n   * | `songselect`           | 0xF3        |  243    |\n   * | `tunerequest`          | 0xF6        |  246    |\n   * | `sysexend`             | 0xF7        |  247    |\n   *\n   * The `sysexend` message is never actually received. It simply ends a sysex stream.\n   *\n   * **System Real-Time Messages**\n   *\n   * | Function               | Hexadecimal | Decimal |\n   * |------------------------|-------------|---------|\n   * | `clock`                | 0xF8        |  248    |\n   * | `start`                | 0xFA        |  250    |\n   * | `continue`             | 0xFB        |  251    |\n   * | `stop`                 | 0xFC        |  252    |\n   * | `activesensing`        | 0xFE        |  254    |\n   * | `reset`                | 0xFF        |  255    |\n   *\n   * Values 249 and 253 are relayed by the\n   * [Web MIDI API](https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API) but they do not\n   * serve any specific purpose. The\n   * [MIDI 1.0 spec](https://www.midi.org/specifications/item/table-1-summary-of-midi-message)\n   * simply states that they are undefined/reserved.\n   *\n   * **Custom Messages**\n   *\n   * These two messages are mostly for internal use. They are not MIDI messages and cannot be sent\n   * or forwarded.\n   *\n   * | Function               | Hexadecimal | Decimal |\n   * |------------------------|-------------|---------|\n   * | `midimessage`          |             |  0      |\n   * | `unknownsystemmessage` |             |  -1     |\n   *\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @since 3.1\n   * @static\n   */\n  static get SYSTEM_MESSAGES() {\n    return {\n      // System common messages\n      sysex: 240,\n      // 240\n      timecode: 241,\n      // 241\n      songposition: 242,\n      // 242\n      songselect: 243,\n      // 243\n      tunerequest: 246,\n      // 246\n      tuningrequest: 246,\n      // for backwards-compatibility (deprecated in version 3.0)\n      sysexend: 247,\n      // 247 (never actually received - simply ends a sysex)\n      // System real-time messages\n      clock: 248,\n      // 248\n      start: 250,\n      // 250\n      continue: 251,\n      // 251\n      stop: 252,\n      // 252\n      activesensing: 254,\n      // 254\n      reset: 255,\n      // 255\n      // Custom WebMidi.js messages\n      midimessage: 0,\n      unknownsystemmessage: -1\n    };\n  }\n  /**\n   * @enum {Object.<string, number>}\n   * @readonly\n   * @deprecated since 3.1 (use Enumerations.SYSTEM_MESSAGES instead)\n   * @private\n   * @static\n   */\n  static get MIDI_SYSTEM_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_SYSTEM_MESSAGES enum has been deprecated. Use the Enumerations.SYSTEM_MESSAGES enum instead."\n    ), i.SYSTEM_MESSAGES;\n  }\n  /**\n   * Array of channel-specific event names that can be listened for. This includes channel mode\n   * events and RPN/NRPN events.\n   *\n   * @type {string[]}\n   * @readonly\n   */\n  static get CHANNEL_EVENTS() {\n    return [\n      // MIDI channel message events\n      "noteoff",\n      "controlchange",\n      "noteon",\n      "keyaftertouch",\n      "programchange",\n      "channelaftertouch",\n      "pitchbend",\n      // MIDI channel mode events\n      "allnotesoff",\n      "allsoundoff",\n      "localcontrol",\n      "monomode",\n      "omnimode",\n      "resetallcontrollers",\n      // RPN/NRPN events\n      "nrpn",\n      "nrpn-dataentrycoarse",\n      "nrpn-dataentryfine",\n      "nrpn-dataincrement",\n      "nrpn-datadecrement",\n      "rpn",\n      "rpn-dataentrycoarse",\n      "rpn-dataentryfine",\n      "rpn-dataincrement",\n      "rpn-datadecrement",\n      // Legacy (remove in v4)\n      "nrpn-databuttonincrement",\n      "nrpn-databuttondecrement",\n      "rpn-databuttonincrement",\n      "rpn-databuttondecrement"\n    ];\n  }\n}\n/**\n * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.\n *\n * `Note` objects can be played back on a single channel by calling\n * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same\n * output, by calling [`Output.playNote()`]{@link Output#playNote}.\n *\n * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.\n * These can be changed by passing in the appropriate option. It is also possible to set a\n * system-wide default for attack and release velocities by using the\n * [`WebMidi.defaults`](WebMidi#defaults) property.\n *\n * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and\n * [`rawRelease`](#rawRelease) to both get and set the values.\n *\n * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped\n * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to\n * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a\n * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},\n * [`Output.stopNote()`]{@link Output#stopNote} or similar.\n *\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass b {\n  /**\n   * Creates a `Note` object.\n   *\n   * @param value {string|number} The value used to create the note. If an identifier string is used,\n   * it must start with the note letter, optionally followed by an accidental and followed by the\n   * octave number (`"C3"`, `"G#4"`, `"F-1"`, `"Db7"`, etc.). If a number is used, it must be an\n   * integer between 0 and 127. In this case, middle C is considered to be C4 (note number 60).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should be\n   * explicitly stopped.\n   *\n   * @param {number} [options.attack=0.5] The note\'s attack velocity as a float between 0 and 1. If\n   * you wish to use an integer between 0 and 127, use the `rawAttack` option instead. If both\n   * `attack` and `rawAttack` are specified, the latter has precedence.\n   *\n   * @param {number} [options.release=0.5] The note\'s release velocity as a float between 0 and 1. If\n   * you wish to use an integer between 0 and 127, use the `rawRelease` option instead. If both\n   * `release` and `rawRelease` are specified, the latter has precedence.\n   *\n   * @param {number} [options.rawAttack=64] The note\'s attack velocity as an integer between 0 and\n   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both\n   * `attack` and `rawAttack` are specified, the latter has precedence.\n   *\n   * @param {number} [options.rawRelease=64] The note\'s release velocity as an integer between 0 and\n   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both\n   * `release` and `rawRelease` are specified, the latter has precedence.\n   *\n   * @throws {Error} Invalid note identifier\n   * @throws {RangeError} Invalid name value\n   * @throws {RangeError} Invalid accidental value\n   * @throws {RangeError} Invalid octave value\n   * @throws {RangeError} Invalid duration value\n   * @throws {RangeError} Invalid attack value\n   * @throws {RangeError} Invalid release value\n   */\n  constructor(e, t = {}) {\n    this.duration = l.defaults.note.duration, this.attack = l.defaults.note.attack, this.release = l.defaults.note.release, t.duration != null && (this.duration = t.duration), t.attack != null && (this.attack = t.attack), t.rawAttack != null && (this.attack = o.from7bitToFloat(t.rawAttack)), t.release != null && (this.release = t.release), t.rawRelease != null && (this.release = o.from7bitToFloat(t.rawRelease)), Number.isInteger(e) ? this.identifier = o.toNoteIdentifier(e) : this.identifier = e;\n  }\n  /**\n   * The name, optional accidental and octave of the note, as a string.\n   * @type {string}\n   * @since 3.0.0\n   */\n  get identifier() {\n    return this._name + (this._accidental || "") + this._octave;\n  }\n  set identifier(e) {\n    const t = o.getNoteDetails(e);\n    if (l.validation && !e)\n      throw new Error("Invalid note identifier");\n    this._name = t.name, this._accidental = t.accidental, this._octave = t.octave;\n  }\n  /**\n   * The name (letter) of the note. If you need the full name with octave and accidental, you can\n   * use the [`identifier`]{@link Note#identifier} property instead.\n   * @type {string}\n   * @since 3.0.0\n   */\n  get name() {\n    return this._name;\n  }\n  set name(e) {\n    if (l.validation && (e = e.toUpperCase(), !["C", "D", "E", "F", "G", "A", "B"].includes(e)))\n      throw new Error("Invalid name value");\n    this._name = e;\n  }\n  /**\n   * The accidental (#, ##, b or bb) of the note.\n   * @type {string}\n   * @since 3.0.0\n   */\n  get accidental() {\n    return this._accidental;\n  }\n  set accidental(e) {\n    if (l.validation && (e = e.toLowerCase(), !["#", "##", "b", "bb"].includes(e)))\n      throw new Error("Invalid accidental value");\n    this._accidental = e;\n  }\n  /**\n   * The octave of the note.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get octave() {\n    return this._octave;\n  }\n  set octave(e) {\n    if (l.validation && (e = parseInt(e), isNaN(e)))\n      throw new Error("Invalid octave value");\n    this._octave = e;\n  }\n  /**\n   * The duration of the note as a positive decimal number representing the number of milliseconds\n   * that the note should play for.\n   *\n   * @type {number}\n   * @since 3.0.0\n   */\n  get duration() {\n    return this._duration;\n  }\n  set duration(e) {\n    if (l.validation && (e = parseFloat(e), isNaN(e) || e === null || e < 0))\n      throw new RangeError("Invalid duration value.");\n    this._duration = e;\n  }\n  /**\n   * The attack velocity of the note as an integer between 0 and 1.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get attack() {\n    return this._attack;\n  }\n  set attack(e) {\n    if (l.validation && (e = parseFloat(e), isNaN(e) || !(e >= 0 && e <= 1)))\n      throw new RangeError("Invalid attack value.");\n    this._attack = e;\n  }\n  /**\n   * The release velocity of the note as an integer between 0 and 1.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get release() {\n    return this._release;\n  }\n  set release(e) {\n    if (l.validation && (e = parseFloat(e), isNaN(e) || !(e >= 0 && e <= 1)))\n      throw new RangeError("Invalid release value.");\n    this._release = e;\n  }\n  /**\n   * The attack velocity of the note as a positive integer between 0 and 127.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get rawAttack() {\n    return o.fromFloatTo7Bit(this._attack);\n  }\n  set rawAttack(e) {\n    this._attack = o.from7bitToFloat(e);\n  }\n  /**\n   * The release velocity of the note as a positive integer between 0 and 127.\n   * @type {number}\n   * @since 3.0.0\n   */\n  get rawRelease() {\n    return o.fromFloatTo7Bit(this._release);\n  }\n  set rawRelease(e) {\n    this._release = o.from7bitToFloat(e);\n  }\n  /**\n   * The MIDI number of the note (`0` - `127`). This number is derived from the note identifier\n   * using C4 as a reference for middle C.\n   *\n   * @type {number}\n   * @readonly\n   * @since 3.0.0\n   */\n  get number() {\n    return o.toNoteNumber(this.identifier);\n  }\n  /**\n   * Returns a MIDI note number offset by octave and/or semitone. If the calculated value is less\n   * than 0, 0 will be returned. If the calculated value is more than 127, 127 will be returned. If\n   * an invalid value is supplied, 0 will be used.\n   *\n   * @param [octaveOffset] {number} An integer to offset the note number by octave.\n   * @param [semitoneOffset] {number} An integer to offset the note number by semitone.\n   * @returns {number} An integer between 0 and 127\n   */\n  getOffsetNumber(e = 0, t = 0) {\n    return l.validation && (e = parseInt(e) || 0, t = parseInt(t) || 0), Math.min(Math.max(this.number + e * 12 + t, 0), 127);\n  }\n}\n/**\n * The `Utilities` class contains general-purpose utility methods. All methods are static and\n * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.\n *\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass o {\n  /**\n   * Returns a MIDI note number matching the identifier passed in the form of a string. The\n   * identifier must include the octave number. The identifier also optionally include a sharp (#),\n   * a double sharp (##), a flat (b) or a double flat (bb) symbol. For example, these are all valid\n   * identifiers: C5, G4, D#-1, F0, Gb7, Eb-1, Abb4, B##6, etc.\n   *\n   * When converting note identifiers to numbers, C4 is considered to be middle C (MIDI note number\n   * 60) as per the scientific pitch notation standard.\n   *\n   * The resulting note number can be offset by using the `octaveOffset` parameter.\n   *\n   * @param identifier {string} The identifier in the form of a letter, followed by an optional "#",\n   * "##", "b" or "bb" followed by the octave number. For exemple: C5, G4, D#-1, F0, Gb7, Eb-1,\n   * Abb4, B##6, etc.\n   *\n   * @param {number} [octaveOffset=0] A integer to offset the octave by.\n   *\n   * @returns {number} The MIDI note number (an integer between 0 and 127).\n   *\n   * @throws RangeError Invalid \'octaveOffset\' value\n   *\n   * @throws TypeError Invalid note identifier\n   *\n   * @license Apache-2.0\n   * @since 3.0.0\n   * @static\n   */\n  static toNoteNumber(e, t = 0) {\n    if (t = t == null ? 0 : parseInt(t), isNaN(t)) throw new RangeError("Invalid \'octaveOffset\' value");\n    typeof e != "string" && (e = "");\n    const n = this.getNoteDetails(e);\n    if (!n) throw new TypeError("Invalid note identifier");\n    const r = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };\n    let s = (n.octave + 1 + t) * 12;\n    if (s += r[n.name], n.accidental && (n.accidental.startsWith("b") ? s -= n.accidental.length : s += n.accidental.length), s < 0 || s > 127) throw new RangeError("Invalid octaveOffset value");\n    return s;\n  }\n  /**\n   * Given a proper note identifier (`C#4`, `Gb-1`, etc.) or a valid MIDI note number (0-127), this\n   * method returns an object containing broken down details about the specified note (uppercase\n   * letter, accidental and octave).\n   *\n   * When a number is specified, the translation to note is done using a value of 60 for middle C\n   * (C4 = middle C).\n   *\n   * @param value {string|number} A note identifier A  atring ("C#4", "Gb-1", etc.) or a MIDI note\n   * number (0-127).\n   *\n   * @returns {{accidental: string, identifier: string, name: string, octave: number }}\n   *\n   * @throws TypeError Invalid note identifier\n   *\n   * @since 3.0.0\n   * @static\n   */\n  static getNoteDetails(e) {\n    Number.isInteger(e) && (e = this.toNoteIdentifier(e));\n    const t = e.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\\d+)$/i);\n    if (!t) throw new TypeError("Invalid note identifier");\n    const n = t[1].toUpperCase(), r = parseInt(t[3]);\n    let s = t[2].toLowerCase();\n    return s = s === "" ? void 0 : s, {\n      accidental: s,\n      identifier: n + (s || "") + r,\n      name: n,\n      octave: r\n    };\n  }\n  /**\n   * Returns a sanitized array of valid MIDI channel numbers (1-16). The parameter should be a\n   * single integer or an array of integers.\n   *\n   * For backwards-compatibility, passing `undefined` as a parameter to this method results in all\n   * channels being returned (1-16). Otherwise, parameters that cannot successfully be parsed to\n   * integers between 1 and 16 are silently ignored.\n   *\n   * @param [channel] {number|number[]} An integer or an array of integers to parse as channel\n   * numbers.\n   *\n   * @returns {number[]} An array of 0 or more valid MIDI channel numbers.\n   *\n   * @since 3.0.0\n   * @static\n   */\n  static sanitizeChannels(e) {\n    let t;\n    if (l.validation) {\n      if (e === "all")\n        t = ["all"];\n      else if (e === "none")\n        return [];\n    }\n    return Array.isArray(e) ? t = e : t = [e], t.indexOf("all") > -1 && (t = i.MIDI_CHANNEL_NUMBERS), t.map(function(n) {\n      return parseInt(n);\n    }).filter(function(n) {\n      return n >= 1 && n <= 16;\n    });\n  }\n  /**\n   * Returns a valid timestamp, relative to the navigation start of the document, derived from the\n   * `time` parameter. If the parameter is a string starting with the "+" sign and followed by a\n   * number, the resulting timestamp will be the sum of the current timestamp plus that number. If\n   * the parameter is a positive number, it will be returned as is. Otherwise, false will be\n   * returned.\n   *\n   * @param [time] {number|string} The time string (e.g. `"+2000"`) or number to parse\n   * @return {number|false} A positive number or `false` (if the time cannot be converted)\n   *\n   * @since 3.0.0\n   * @static\n   */\n  static toTimestamp(e) {\n    let t = !1;\n    const n = parseFloat(e);\n    return isNaN(n) ? !1 : (typeof e == "string" && e.substring(0, 1) === "+" ? n >= 0 && (t = l.time + n) : n >= 0 && (t = n), t);\n  }\n  /**\n   * Returns a valid MIDI note number (0-127) given the specified input. The input usually is a\n   * string containing a note identifier (`"C3"`, `"F#4"`, `"D-2"`, `"G8"`, etc.). If an integer\n   * between 0 and 127 is passed, it will simply be returned as is (for convenience). Other strings\n   * will be parsed for integer value, if possible.\n   *\n   * If the input is an identifier, the resulting note number is offset by the `octaveOffset`\n   * parameter. For example, if you pass in "C4" (note number 60) and the `octaveOffset` value is\n   * -2, the resulting MIDI note number will be 36.\n   *\n   * @param input {string|number} A string or number to extract the MIDI note number from.\n   * @param octaveOffset {number} An integer to offset the octave by\n   *\n   * @returns {number|false} A valid MIDI note number (0-127) or `false` if the input could not\n   * successfully be parsed to a note number.\n   *\n   * @since 3.0.0\n   * @static\n   */\n  static guessNoteNumber(e, t) {\n    t = parseInt(t) || 0;\n    let n = !1;\n    if (Number.isInteger(e) && e >= 0 && e <= 127)\n      n = parseInt(e);\n    else if (parseInt(e) >= 0 && parseInt(e) <= 127)\n      n = parseInt(e);\n    else if (typeof e == "string" || e instanceof String)\n      try {\n        n = this.toNoteNumber(e.trim(), t);\n      } catch {\n        return !1;\n      }\n    return n;\n  }\n  /**\n   * Returns an identifier string representing a note name (with optional accidental) followed by an\n   * octave number. The octave can be offset by using the `octaveOffset` parameter.\n   *\n   * @param {number} number The MIDI note number to convert to a note identifier\n   * @param {number} octaveOffset An offset to apply to the resulting octave\n   *\n   * @returns {string}\n   *\n   * @throws RangeError Invalid note number\n   * @throws RangeError Invalid octaveOffset value\n   *\n   * @since 3.0.0\n   * @static\n   */\n  static toNoteIdentifier(e, t) {\n    if (e = parseInt(e), isNaN(e) || e < 0 || e > 127) throw new RangeError("Invalid note number");\n    if (t = t == null ? 0 : parseInt(t), isNaN(t)) throw new RangeError("Invalid octaveOffset value");\n    const n = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"], r = Math.floor(e / 12 - 1) + t;\n    return n[e % 12] + r.toString();\n  }\n  /**\n   * Converts the `input` parameter to a valid [`Note`]{@link Note} object. The input usually is an\n   * unsigned integer (0-127) or a note identifier (`"C4"`, `"G#5"`, etc.). If the input is a\n   * [`Note`]{@link Note} object, it will be returned as is.\n   *\n   * If the input is a note number or identifier, it is possible to specify options by providing the\n   * `options` parameter.\n   *\n   * @param [input] {number|string|Note}\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should\n   * be explicitly stopped.\n   *\n   * @param {number} [options.attack=0.5] The note\'s attack velocity as a float between 0 and 1. If\n   * you wish to use an integer between 0 and 127, use the `rawAttack` option instead. If both\n   * `attack` and `rawAttack` are specified, the latter has precedence.\n   *\n   * @param {number} [options.release=0.5] The note\'s release velocity as a float between 0 and 1. If\n   * you wish to use an integer between 0 and 127, use the `rawRelease` option instead. If both\n   * `release` and `rawRelease` are specified, the latter has precedence.\n   *\n   * @param {number} [options.rawAttack=64] The note\'s attack velocity as an integer between 0 and\n   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both\n   * `attack` and `rawAttack` are specified, the latter has precedence.\n   *\n   * @param {number} [options.rawRelease=64] The note\'s release velocity as an integer between 0 and\n   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both\n   * `release` and `rawRelease` are specified, the latter has precedence.\n   *\n   * @param {number} [options.octaveOffset=0] An integer to offset the octave by. **This is only\n   * used when the input value is a note identifier.**\n   *\n   * @returns {Note}\n   *\n   * @throws TypeError The input could not be parsed to a note\n   *\n   * @since version 3.0.0\n   * @static\n   */\n  static buildNote(e, t = {}) {\n    if (t.octaveOffset = parseInt(t.octaveOffset) || 0, e instanceof b) return e;\n    let n = this.guessNoteNumber(e, t.octaveOffset);\n    if (n === !1)\n      throw new TypeError(`The input could not be parsed as a note (${e})`);\n    return t.octaveOffset = void 0, new b(n, t);\n  }\n  /**\n   * Converts an input value, which can be an unsigned integer (0-127), a note identifier, a\n   * [`Note`]{@link Note}  object or an array of the previous types, to an array of\n   * [`Note`]{@link Note}  objects.\n   *\n   * [`Note`]{@link Note}  objects are returned as is. For note numbers and identifiers, a\n   * [`Note`]{@link Note} object is created with the options specified. An error will be thrown when\n   * encountering invalid input.\n   *\n   * Note: if both the `attack` and `rawAttack` options are specified, the later has priority. The\n   * same goes for `release` and `rawRelease`.\n   *\n   * @param [notes] {number|string|Note|number[]|string[]|Note[]}\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the note should\n   * be explicitly stopped.\n   *\n   * @param {number} [options.attack=0.5] The note\'s attack velocity as a float between 0 and 1. If\n   * you wish to use an integer between 0 and 127, use the `rawAttack` option instead. If both\n   * `attack` and `rawAttack` are specified, the latter has precedence.\n   *\n   * @param {number} [options.release=0.5] The note\'s release velocity as a float between 0 and 1. If\n   * you wish to use an integer between 0 and 127, use the `rawRelease` option instead. If both\n   * `release` and `rawRelease` are specified, the latter has precedence.\n   *\n   * @param {number} [options.rawAttack=64] The note\'s attack velocity as an integer between 0 and\n   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both\n   * `attack` and `rawAttack` are specified, the latter has precedence.\n   *\n   * @param {number} [options.rawRelease=64] The note\'s release velocity as an integer between 0 and\n   * 127. If you wish to use a float between 0 and 1, use the `release` option instead. If both\n   * `release` and `rawRelease` are specified, the latter has precedence.\n   *\n   * @param {number} [options.octaveOffset=0] An integer to offset the octave by. **This is only\n   * used when the input value is a note identifier.**\n   *\n   * @returns {Note[]}\n   *\n   * @throws TypeError An element could not be parsed as a note.\n   *\n   * @since 3.0.0\n   * @static\n   */\n  static buildNoteArray(e, t = {}) {\n    let n = [];\n    return Array.isArray(e) || (e = [e]), e.forEach((r) => {\n      n.push(this.buildNote(r, t));\n    }), n;\n  }\n  /**\n   * Returns a number between 0 and 1 representing the ratio of the input value divided by 127 (7\n   * bit). The returned value is restricted between 0 and 1 even if the input is greater than 127 or\n   * smaller than 0.\n   *\n   * Passing `Infinity` will return `1` and passing `-Infinity` will return `0`. Otherwise, when the\n   * input value cannot be converted to an integer, the method returns 0.\n   *\n   * @param value {number} A positive integer between 0 and 127 (inclusive)\n   * @returns {number} A number between 0 and 1 (inclusive)\n   * @static\n   */\n  static from7bitToFloat(e) {\n    return e === 1 / 0 && (e = 127), e = parseInt(e) || 0, Math.min(Math.max(e / 127, 0), 1);\n  }\n  /**\n   * Returns an integer between 0 and 127 which is the result of multiplying the input value by\n   * 127. The input value should be a number between 0 and 1 (inclusively). The returned value is\n   * restricted between 0 and 127 even if the input is greater than 1 or smaller than 0.\n   *\n   * Passing `Infinity` will return `127` and passing `-Infinity` will return `0`. Otherwise, when\n   * the input value cannot be converted to a number, the method returns 0.\n   *\n   * @param value {number} A positive float between 0 and 1 (inclusive)\n   * @returns {number} A number between 0 and 127 (inclusive)\n   * @static\n   */\n  static fromFloatTo7Bit(e) {\n    return e === 1 / 0 && (e = 1), e = parseFloat(e) || 0, Math.min(Math.max(Math.round(e * 127), 0), 127);\n  }\n  /**\n   * Combines and converts MSB and LSB values (0-127) to a float between 0 and 1. The returned value\n   * is within between 0 and 1 even if the result is greater than 1 or smaller than 0.\n   *\n   * @param msb {number} The most significant byte as a integer between 0 and 127.\n   * @param [lsb=0] {number} The least significant byte as a integer between 0 and 127.\n   * @returns {number} A float between 0 and 1.\n   */\n  static fromMsbLsbToFloat(e, t = 0) {\n    l.validation && (e = Math.min(Math.max(parseInt(e) || 0, 0), 127), t = Math.min(Math.max(parseInt(t) || 0, 0), 127));\n    const n = ((e << 7) + t) / 16383;\n    return Math.min(Math.max(n, 0), 1);\n  }\n  /**\n   * Extracts 7bit MSB and LSB values from the supplied float.\n   *\n   * @param value {number} A float between 0 and 1\n   * @returns {{lsb: number, msb: number}}\n   */\n  static fromFloatToMsbLsb(e) {\n    l.validation && (e = Math.min(Math.max(parseFloat(e) || 0, 0), 1));\n    const t = Math.round(e * 16383);\n    return {\n      msb: t >> 7,\n      lsb: t & 127\n    };\n  }\n  /**\n   * Returns the supplied MIDI note number offset by the requested octave and semitone values. If\n   * the calculated value is less than 0, 0 will be returned. If the calculated value is more than\n   * 127, 127 will be returned. If an invalid offset value is supplied, 0 will be used.\n   *\n   * @param number {number} The MIDI note to offset as an integer between 0 and 127.\n   * @param octaveOffset {number} An integer to offset the note by (in octave)\n   * @param octaveOffset {number} An integer to offset the note by (in semitones)\n   * @returns {number} An integer between 0 and 127\n   *\n   * @throws {Error} Invalid note number\n   * @static\n   */\n  static offsetNumber(e, t = 0, n = 0) {\n    if (l.validation) {\n      if (e = parseInt(e), isNaN(e)) throw new Error("Invalid note number");\n      t = parseInt(t) || 0, n = parseInt(n) || 0;\n    }\n    return Math.min(Math.max(e + t * 12 + n, 0), 127);\n  }\n  /**\n   * Returns the name of the first property of the supplied object whose value is equal to the one\n   * supplied. If nothing is found, `undefined` is returned.\n   *\n   * @param object {object} The object to look for the property in.\n   * @param value {*} Any value that can be expected to be found in the object\'s properties.\n   * @returns {string|undefined} The name of the matching property or `undefined` if nothing is\n   * found.\n   * @static\n   */\n  static getPropertyByValue(e, t) {\n    return Object.keys(e).find((n) => e[n] === t);\n  }\n  /**\n   * Returns the name of a control change message matching the specified number (0-127). Some valid\n   * control change numbers do not have a specific name or purpose assigned in the MIDI\n   * [spec](https://midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2).\n   * In these cases, the method returns `controllerXXX` (where XXX is the number).\n   *\n   * @param {number} number An integer (0-127) representing the control change message\n   * @returns {string|undefined} The matching control change name or `undefined` if no match was\n   * found.\n   *\n   * @static\n   */\n  static getCcNameByNumber(e) {\n    if (!(l.validation && (e = parseInt(e), !(e >= 0 && e <= 127))))\n      return i.CONTROL_CHANGE_MESSAGES[e].name;\n  }\n  /**\n   * Returns the number of a control change message matching the specified name.\n   *\n   * @param {string} name A string representing the control change message\n   * @returns {string|undefined} The matching control change number or `undefined` if no match was\n   * found.\n   *\n   * @since 3.1\n   * @static\n   */\n  static getCcNumberByName(e) {\n    let t = i.CONTROL_CHANGE_MESSAGES.find((n) => n.name === e);\n    return t ? t.number : i.MIDI_CONTROL_CHANGE_MESSAGES[e];\n  }\n  /**\n   * Returns the channel mode name matching the specified number. If no match is found, the function\n   * returns `false`.\n   *\n   * @param {number} number An integer representing the channel mode message (120-127)\n   * @returns {string|false} The name of the matching channel mode or `false` if no match could be\n   * found.\n   *\n   * @since 2.0.0\n   */\n  static getChannelModeByNumber(e) {\n    if (!(e >= 120 && e <= 127)) return !1;\n    for (let t in i.CHANNEL_MODE_MESSAGES)\n      if (i.CHANNEL_MODE_MESSAGES.hasOwnProperty(t) && e === i.CHANNEL_MODE_MESSAGES[t])\n        return t;\n    return !1;\n  }\n  /**\n   * Indicates whether the execution environment is Node.js (`true`) or not (`false`)\n   * @type {boolean}\n   */\n  static get isNode() {\n    return typeof process < "u" && process.versions != null && process.versions.node != null;\n  }\n  /**\n   * Indicates whether the execution environment is a browser (`true`) or not (`false`)\n   * @type {boolean}\n   */\n  static get isBrowser() {\n    return typeof window < "u" && typeof window.document < "u";\n  }\n}\n/**\n * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are\n * provided by an [`Output`](Output) port which, itself, is made available by a device. The\n * `OutputChannel` object is derived from the host\'s MIDI subsystem and should not be instantiated\n * directly.\n *\n * All 16 `OutputChannel` objects can be found inside the parent output\'s\n * [`channels`]{@link Output#channels} property.\n *\n * @param {Output} output The [`Output`](Output) this channel belongs to.\n * @param {number} number The MIDI channel number (`1` - `16`).\n *\n * @extends EventEmitter\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass J extends E {\n  /**\n   * Creates an `OutputChannel` object.\n   *\n   * @param {Output} output The [`Output`](Output) this channel belongs to.\n   * @param {number} number The MIDI channel number (`1` - `16`).\n   */\n  constructor(e, t) {\n    super(), this._output = e, this._number = t, this._octaveOffset = 0;\n  }\n  /**\n   * Unlinks the MIDI subsystem, removes all listeners attached to the channel and nulls the channel\n   * number. This method is mostly for internal use. It has not been prefixed with an underscore\n   * since it is called by other objects such as the `Output` object.\n   *\n   * @private\n   */\n  destroy() {\n    this._output = null, this._number = null, this._octaveOffset = 0, this.removeListener();\n  }\n  /**\n   * Sends a MIDI message on the MIDI output port. If no time is specified, the message will be\n   * sent immediately. The message should be an array of 8-bit unsigned integers (`0` - `225`),\n   * a\n   * [`Uint8Array`]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}\n   * object or a [`Message`](Message) object.\n   *\n   * It is usually not necessary to use this method directly as you can use one of the simpler\n   * helper methods such as [`playNote()`](#playNote), [`stopNote()`](#stopNote),\n   * [`sendControlChange()`](#sendControlChange), etc.\n   *\n   * Details on the format of MIDI messages are available in the summary of\n   * [MIDI messages]{@link https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message}\n   * from the MIDI Manufacturers Association.\n   *\n   * @param message {number[]|Uint8Array|Message} A `Message` object, an array of 8-bit unsigned\n   * integers or a `Uint8Array` object (not available in Node.js) containing the message bytes.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The first byte (status) must be an integer between 128 and 255.\n   *\n   * @throws {RangeError} Data bytes must be integers between 0 and 255.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  send(e, t = { time: 0 }) {\n    return this.output.send(e, t), this;\n  }\n  /**\n   * Sends a MIDI **key aftertouch** message at the scheduled time. This is a key-specific\n   * aftertouch. For a channel-wide aftertouch message, use\n   * [`sendChannelAftertouch()`]{@link #sendChannelAftertouch}.\n   *\n   * @param target {number|Note|string|number[]|Note[]|string[]} The note(s) for which you are sending\n   * an aftertouch value. The notes can be specified by using a MIDI note number (`0` - `127`), a\n   * [`Note`](Note) object, a note identifier (e.g. `C3`, `G#4`, `F-1`, `Db7`) or an array of the\n   * previous types. When using a note identifier, octave range must be between `-1` and `9`. The\n   * lowest note is `C-1` (MIDI note number `0`) and the highest note is `G9` (MIDI note number\n   * `127`).\n   *\n   * When using a note identifier, the octave value will be offset by the local\n   * [`octaveOffset`](#octaveOffset) and by\n   * [`Output.octaveOffset`](Output#octaveOffset) and [`WebMidi.octaveOffset`](WebMidi#octaveOffset)\n   * (if those values are not `0`). When using a key number, `octaveOffset` values are ignored.\n   *\n   * @param [pressure=0.5] {number} The pressure level (between `0` and `1`). An invalid pressure\n   * value will silently trigger the default behaviour. If the `rawValue` option is set to `true`,\n   * the pressure is defined by using an integer between `0` and `127`.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @return {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   * @throws RangeError Invalid key aftertouch value.\n   */\n  sendKeyAftertouch(e, t, n = {}) {\n    if (l.validation) {\n      if (n.useRawValue && (n.rawValue = n.useRawValue), isNaN(parseFloat(t)))\n        throw new RangeError("Invalid key aftertouch value.");\n      if (n.rawValue) {\n        if (!(t >= 0 && t <= 127 && Number.isInteger(t)))\n          throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.");\n      } else if (!(t >= 0 && t <= 1))\n        throw new RangeError("Key aftertouch value must be a float between 0 and 1.");\n    }\n    n.rawValue || (t = o.fromFloatTo7Bit(t));\n    const r = l.octaveOffset + this.output.octaveOffset + this.octaveOffset;\n    return Array.isArray(e) || (e = [e]), o.buildNoteArray(e).forEach((s) => {\n      this.send(\n        [\n          (i.CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1),\n          s.getOffsetNumber(r),\n          t\n        ],\n        { time: o.toTimestamp(n.time) }\n      );\n    }), this;\n  }\n  /**\n   * Sends a MIDI **control change** message to the channel at the scheduled time. The control\n   * change message to send can be specified numerically (`0` to `127`) or by using one of the\n   * following common names:\n   *\n   * | Number | Name                          |\n   * |--------|-------------------------------|\n   * | 0      |`bankselectcoarse`             |\n   * | 1      |`modulationwheelcoarse`        |\n   * | 2      |`breathcontrollercoarse`       |\n   * | 4      |`footcontrollercoarse`         |\n   * | 5      |`portamentotimecoarse`         |\n   * | 6      |`dataentrycoarse`              |\n   * | 7      |`volumecoarse`                 |\n   * | 8      |`balancecoarse`                |\n   * | 10     |`pancoarse`                    |\n   * | 11     |`expressioncoarse`             |\n   * | 12     |`effectcontrol1coarse`         |\n   * | 13     |`effectcontrol2coarse`         |\n   * | 18     |`generalpurposeslider3`        |\n   * | 19     |`generalpurposeslider4`        |\n   * | 32     |`bankselectfine`               |\n   * | 33     |`modulationwheelfine`          |\n   * | 34     |`breathcontrollerfine`         |\n   * | 36     |`footcontrollerfine`           |\n   * | 37     |`portamentotimefine`           |\n   * | 38     |`dataentryfine`                |\n   * | 39     |`volumefine`                   |\n   * | 40     |`balancefine`                  |\n   * | 42     |`panfine`                      |\n   * | 43     |`expressionfine`               |\n   * | 44     |`effectcontrol1fine`           |\n   * | 45     |`effectcontrol2fine`           |\n   * | 64     |`holdpedal`                    |\n   * | 65     |`portamento`                   |\n   * | 66     |`sustenutopedal`               |\n   * | 67     |`softpedal`                    |\n   * | 68     |`legatopedal`                  |\n   * | 69     |`hold2pedal`                   |\n   * | 70     |`soundvariation`               |\n   * | 71     |`resonance`                    |\n   * | 72     |`soundreleasetime`             |\n   * | 73     |`soundattacktime`              |\n   * | 74     |`brightness`                   |\n   * | 75     |`soundcontrol6`                |\n   * | 76     |`soundcontrol7`                |\n   * | 77     |`soundcontrol8`                |\n   * | 78     |`soundcontrol9`                |\n   * | 79     |`soundcontrol10`               |\n   * | 80     |`generalpurposebutton1`        |\n   * | 81     |`generalpurposebutton2`        |\n   * | 82     |`generalpurposebutton3`        |\n   * | 83     |`generalpurposebutton4`        |\n   * | 91     |`reverblevel`                  |\n   * | 92     |`tremololevel`                 |\n   * | 93     |`choruslevel`                  |\n   * | 94     |`celestelevel`                 |\n   * | 95     |`phaserlevel`                  |\n   * | 96     |`dataincrement`                |\n   * | 97     |`datadecrement`                |\n   * | 98     |`nonregisteredparametercoarse` |\n   * | 99     |`nonregisteredparameterfine`   |\n   * | 100    |`registeredparametercoarse`    |\n   * | 101    |`registeredparameterfine`      |\n   * | 120    |`allsoundoff`                  |\n   * | 121    |`resetallcontrollers`          |\n   * | 122    |`localcontrol`                 |\n   * | 123    |`allnotesoff`                  |\n   * | 124    |`omnimodeoff`                  |\n   * | 125    |`omnimodeon`                   |\n   * | 126    |`monomodeon`                   |\n   * | 127    |`polymodeon`                   |\n   *\n   * As you can see above, not all control change message have a matching name. This does not mean\n   * you cannot use the others. It simply means you will need to use their number\n   * (`0` to `127`) instead of their name. While you can still use them, numbers `120` to `127` are\n   * usually reserved for *channel mode* messages. See\n   * [`sendChannelMode()`]{@link OutputChannel#sendChannelMode} method for more info.\n   *\n   * To view a detailed list of all available **control change** messages, please consult "Table 3 -\n   * Control Change Messages" from the [MIDI Messages](\n   * https://www.midi.org/specifications/item/table-3-control-change-messages-data-bytes-2)\n   * specification.\n   *\n   * **Note**: messages #0-31 (MSB) are paired with messages #32-63 (LSB). For example, message #1\n   * (`modulationwheelcoarse`) can be accompanied by a second control change message for\n   * `modulationwheelfine` to achieve a greater level of precision. if you want to specify both MSB\n   * and LSB for messages between `0` and `31`, you can do so by passing a 2-value array as the\n   * second parameter.\n   *\n   * @param {number|string} controller The MIDI controller name or number (`0` - `127`).\n   *\n   * @param {number|number[]} value The value to send (0-127). You can also use a two-position array\n   * for controllers 0 to 31. In this scenario, the first value will be sent as usual and the second\n   * value will be sent to the matching LSB controller (which is obtained by adding 32 to the first\n   * controller)\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} Controller numbers must be between 0 and 127.\n   * @throws {RangeError} Invalid controller name.\n   * @throws {TypeError} The value array must have a length of 2.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   * @license Apache-2.0\n   * @since 3.0.0\n   */\n  sendControlChange(e, t, n = {}) {\n    if (typeof e == "string" && (e = o.getCcNumberByName(e)), Array.isArray(t) || (t = [t]), l.validation) {\n      if (e === void 0)\n        throw new TypeError(\n          "Control change must be identified with a valid name or an integer between 0 and 127."\n        );\n      if (!Number.isInteger(e) || !(e >= 0 && e <= 127))\n        throw new TypeError("Control change number must be an integer between 0 and 127.");\n      if (t = t.map((r) => {\n        const s = Math.min(Math.max(parseInt(r), 0), 127);\n        if (isNaN(s)) throw new TypeError("Values must be integers between 0 and 127");\n        return s;\n      }), t.length === 2 && e >= 32)\n        throw new TypeError("To use a value array, the controller must be between 0 and 31");\n    }\n    return t.forEach((r, s) => {\n      this.send(\n        [\n          (i.CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1),\n          e + s * 32,\n          t[s]\n        ],\n        { time: o.toTimestamp(n.time) }\n      );\n    }), this;\n  }\n  /**\n   * Selects a MIDI non-registered parameter so it is affected by upcoming data entry, data\n   * increment and data decrement messages.\n   *\n   * @param parameter {number[]} A two-position array specifying the two control bytes that identify\n   * the registered parameter. The NRPN MSB (99 or 0x63) is a position 0. The NRPN LSB (98 or 0x62)\n   * is at position 1.\n   *\n   * @private\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _selectNonRegisteredParameter(e, t = {}) {\n    return this.sendControlChange(99, e[0], t), this.sendControlChange(98, e[1], t), this;\n  }\n  /**\n   * Deselects the currently active MIDI registered parameter so it is no longer affected by data\n   * entry, data increment and data decrement messages.\n   *\n   * Current best practice recommends doing that after each call to\n   * [_setCurrentParameter()]{@link #_setCurrentParameter}.\n   *\n   * @private\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _deselectRegisteredParameter(e = {}) {\n    return this.sendControlChange(101, 127, e), this.sendControlChange(100, 127, e), this;\n  }\n  /**\n   * Deselects the currently active MIDI non-registered parameter so it is no longer affected by\n   * data entry, data increment and data decrement messages.\n   *\n   * @private\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _deselectNonRegisteredParameter(e = {}) {\n    return this.sendControlChange(101, 127, e), this.sendControlChange(100, 127, e), this;\n  }\n  /**\n   * Selects a MIDI registered parameter so it is affected by upcoming data entry, data increment\n   * and data decrement messages.\n   *\n   * @private\n   *\n   * @param parameter {number[]} A two-position array of integers specifying the two control bytes\n   * (0x65, 0x64) that identify the registered parameter. The integers must be between 0 and 127.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _selectRegisteredParameter(e, t = {}) {\n    return this.sendControlChange(101, e[0], t), this.sendControlChange(100, e[1], t), this;\n  }\n  /**\n   * Sets the value of the currently selected MIDI registered parameter.\n   *\n   * @private\n   *\n   * @param data {number|number[]}\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time] If `time` is a string prefixed with `"+"` and followed by\n   * a number, the message will be delayed by that many milliseconds. If the value is a number, the\n   * operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  _setCurrentParameter(e, t = {}) {\n    return e = [].concat(e), this.sendControlChange(6, e[0], t), e.length < 2 ? this : (this.sendControlChange(38, e[1], t), this);\n  }\n  /**\n   * Decrements the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this function:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`\n   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`\n   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`\n   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`\n   *  * Modulation Range (0x00, 0x05): `"modulationrange"`\n   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`\n   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`\n   *  * Gain (0x3D, 0x02): `"gain"`\n   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`\n   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`\n   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`\n   *  * Roll Angle (0x3D, 0x08): `"rollangle"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter\'s name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws TypeError The specified registered parameter is invalid.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendRpnDecrement(e, t = {}) {\n    if (Array.isArray(e) || (e = i.REGISTERED_PARAMETERS[e]), l.validation) {\n      if (e === void 0)\n        throw new TypeError("The specified registered parameter is invalid.");\n      let n = !1;\n      if (Object.getOwnPropertyNames(i.REGISTERED_PARAMETERS).forEach((r) => {\n        i.REGISTERED_PARAMETERS[r][0] === e[0] && i.REGISTERED_PARAMETERS[r][1] === e[1] && (n = !0);\n      }), !n) throw new TypeError("The specified registered parameter is invalid.");\n    }\n    return this._selectRegisteredParameter(e, t), this.sendControlChange(97, 0, t), this._deselectRegisteredParameter(t), this;\n  }\n  /**\n   * Increments the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this function:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`\n   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`\n   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`\n   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`\n   *  * Modulation Range (0x00, 0x05): `"modulationrange"`\n   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`\n   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`\n   *  * Gain (0x3D, 0x02): `"gain"`\n   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`\n   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`\n   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`\n   *  * Roll Angle (0x3D, 0x08): `"rollangle"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter\'s name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws TypeError The specified registered parameter is invalid.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendRpnIncrement(e, t = {}) {\n    if (Array.isArray(e) || (e = i.REGISTERED_PARAMETERS[e]), l.validation) {\n      if (e === void 0)\n        throw new TypeError("The specified registered parameter is invalid.");\n      let n = !1;\n      if (Object.getOwnPropertyNames(i.REGISTERED_PARAMETERS).forEach((r) => {\n        i.REGISTERED_PARAMETERS[r][0] === e[0] && i.REGISTERED_PARAMETERS[r][1] === e[1] && (n = !0);\n      }), !n) throw new TypeError("The specified registered parameter is invalid.");\n    }\n    return this._selectRegisteredParameter(e, t), this.sendControlChange(96, 0, t), this._deselectRegisteredParameter(t), this;\n  }\n  /**\n   * Plays a note or an array of notes on the channel. The first parameter is the note to play. It\n   * can be a single value or an array of the following valid values:\n   *\n   *  - A [`Note`]{@link Note} object\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *\n   * The `playNote()` method sends a **note on** MIDI message for all specified notes. If a\n   * `duration` is set in the `options` parameter or in the [`Note`]{@link Note} object\'s\n   * [`duration`]{@link Note#duration} property, it will also schedule a **note off** message\n   * to end the note after said duration. If no `duration` is set, the note will simply play until\n   * a matching **note off** message is sent with [`stopNote()`]{@link OutputChannel#stopNote} or\n   * [`sendNoteOff()`]{@link OutputChannel#sendNoteOff}.\n   *\n   *  The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using [`Note`]{@link Note} objects, the durations and velocities defined in the\n   * [`Note`]{@link Note} objects have precedence over the ones specified via the method\'s `options`\n   * parameter.\n   *\n   * **Note**: per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`,\n   * `F-1`, `Db7`), a [`Note`]{@link Note} object or an array of the previous types. When using a\n   * note identifier, the octave range must be between `-1` and `9`. The lowest note is `C-1` (MIDI\n   * note number `0`) and the highest note is `G9` (MIDI note number `127`).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number} [options.duration] A positive decimal number larger than `0` representing the\n   * number of milliseconds to wait before sending a **note off** message. If invalid or left\n   * undefined, only a **note on** message will be sent.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`). If the `rawAttack` option is also defined, it will have priority. An invalid velocity\n   * value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawAttack=64] The attack velocity at which to play the note (between\n   * `0` and `127`). This has priority over the `attack` property. An invalid velocity value will\n   * silently trigger the default of 64.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`\n   * and `1`). If the `rawRelease` option is also defined, it will have priority. An invalid\n   * velocity value will silently trigger the default of `0.5`. This is only used with the\n   * **note off** event triggered when `options.duration` is set.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note (between `0`\n   * and `127`). This has priority over the `release` property. An invalid velocity value will\n   * silently trigger the default of 64. This is only used with the **note off** event triggered\n   * when `options.duration` is set.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  playNote(e, t = {}) {\n    this.sendNoteOn(e, t);\n    const n = Array.isArray(e) ? e : [e];\n    for (let r of n)\n      if (parseInt(r.duration) > 0) {\n        const s = {\n          time: (o.toTimestamp(t.time) || l.time) + parseInt(r.duration),\n          release: r.release,\n          rawRelease: r.rawRelease\n        };\n        this.sendNoteOff(r, s);\n      } else if (parseInt(t.duration) > 0) {\n        const s = {\n          time: (o.toTimestamp(t.time) || l.time) + parseInt(t.duration),\n          release: t.release,\n          rawRelease: t.rawRelease\n        };\n        this.sendNoteOff(r, s);\n      }\n    return this;\n  }\n  /**\n   * Sends a **note off** message for the specified notes on the channel. The first parameter is the\n   * note. It can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note name, followed by the octave (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *  - A [`Note`]{@link Note} object\n   *\n   * The execution of the **note off** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using [`Note`]{@link Note} objects, the release velocity defined in the\n   * [`Note`]{@link Note} objects has precedence over the one specified via the method\'s `options`\n   * parameter.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (0-127), a note identifier (e.g. C3, G#4, F-1, Db7), a\n   * [`Note`]{@link Note} object or an array of the previous types. When using a note name, octave\n   * range must be between -1 and 9. The lowest note is C-1 (MIDI note number 0) and the highest\n   * note is G9 (MIDI note number 127).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note\n   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note\n   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `64`.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendNoteOff(e, t = {}) {\n    if (l.validation) {\n      if (t.rawRelease != null && !(t.rawRelease >= 0 && t.rawRelease <= 127))\n        throw new RangeError("The \'rawRelease\' option must be an integer between 0 and 127");\n      if (t.release != null && !(t.release >= 0 && t.release <= 1))\n        throw new RangeError("The \'release\' option must be an number between 0 and 1");\n      t.rawVelocity && (t.rawRelease = t.velocity, console.warn("The \'rawVelocity\' option is deprecated. Use \'rawRelease\' instead.")), t.velocity && (t.release = t.velocity, console.warn("The \'velocity\' option is deprecated. Use \'attack\' instead."));\n    }\n    let n = 64;\n    t.rawRelease != null ? n = t.rawRelease : isNaN(t.release) || (n = Math.round(t.release * 127));\n    const r = l.octaveOffset + this.output.octaveOffset + this.octaveOffset;\n    return o.buildNoteArray(e, { rawRelease: parseInt(n) }).forEach((s) => {\n      this.send(\n        [\n          (i.CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1),\n          s.getOffsetNumber(r),\n          s.rawRelease\n        ],\n        { time: o.toTimestamp(t.time) }\n      );\n    }), this;\n  }\n  /**\n   * Sends a **note off** message for the specified MIDI note number. The first parameter is the\n   * note to stop. It can be a single value or an array of the following valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *  - A [`Note`](Note) object\n   *\n   * The execution of the **note off** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`, `F-1`,\n   * `Db7`) or an array of the previous types. When using a note identifier, octave range must be\n   * between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest note is\n   * `G9` (MIDI note number `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note\n   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note\n   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `64`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  stopNote(e, t = {}) {\n    return this.sendNoteOff(e, t);\n  }\n  /**\n   * Sends a **note on** message for the specified note(s) on the channel. The first parameter is\n   * the note. It can be a single value or an array of the following valid values:\n   *\n   *  - A [`Note`]{@link Note} object\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *\n   *  When passing a [`Note`]{@link Note}object or a note name, the `octaveOffset` will be applied.\n   *  This is not the case when using a note number. In this case, we assume you know exactly which\n   *  MIDI note number should be sent out.\n   *\n   * The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using [`Note`]{@link Note} objects, the attack velocity defined in the\n   * [`Note`]{@link Note} objects has precedence over the one specified via the method\'s `options`\n   * parameter. Also, the `duration` is ignored. If you want to also send a **note off** message,\n   * use the [`playNote()`]{@link #playNote} method instead.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (0-127), a note identifier (e.g. C3, G#4, F-1, Db7), a\n   * [`Note`]{@link Note} object or an array of the previous types.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`).  If the `rawAttack` option is also defined, `rawAttack` will have priority. An invalid\n   * velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawAttack=64] The velocity at which to release the note (between `0`\n   * and `127`). If the `attack` option is also defined, `rawAttack` will have priority. An invalid\n   * velocity value will silently trigger the default of `64`.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendNoteOn(e, t = {}) {\n    if (l.validation) {\n      if (t.rawAttack != null && !(t.rawAttack >= 0 && t.rawAttack <= 127))\n        throw new RangeError("The \'rawAttack\' option must be an integer between 0 and 127");\n      if (t.attack != null && !(t.attack >= 0 && t.attack <= 1))\n        throw new RangeError("The \'attack\' option must be an number between 0 and 1");\n      t.rawVelocity && (t.rawAttack = t.velocity, t.rawRelease = t.release, console.warn("The \'rawVelocity\' option is deprecated. Use \'rawAttack\' or \'rawRelease\'.")), t.velocity && (t.attack = t.velocity, console.warn("The \'velocity\' option is deprecated. Use \'attack\' instead."));\n    }\n    let n = 64;\n    t.rawAttack != null ? n = t.rawAttack : isNaN(t.attack) || (n = Math.round(t.attack * 127));\n    const r = l.octaveOffset + this.output.octaveOffset + this.octaveOffset;\n    return o.buildNoteArray(e, { rawAttack: n }).forEach((s) => {\n      this.send(\n        [\n          (i.CHANNEL_MESSAGES.noteon << 4) + (this.number - 1),\n          s.getOffsetNumber(r),\n          s.rawAttack\n        ],\n        { time: o.toTimestamp(t.time) }\n      );\n    }), this;\n  }\n  /**\n   * Sends a MIDI **channel mode** message. The channel mode message to send can be specified\n   * numerically or by using one of the following common names:\n   *\n   * |  Type                |Number| Shortcut Method                                               |\n   * | ---------------------|------|-------------------------------------------------------------- |\n   * | `allsoundoff`        | 120  | [`sendAllSoundOff()`]{@link #sendAllSoundOff}                 |\n   * | `resetallcontrollers`| 121  | [`sendResetAllControllers()`]{@link #sendResetAllControllers} |\n   * | `localcontrol`       | 122  | [`sendLocalControl()`]{@link #sendLocalControl}               |\n   * | `allnotesoff`        | 123  | [`sendAllNotesOff()`]{@link #sendAllNotesOff}                 |\n   * | `omnimodeoff`        | 124  | [`sendOmniMode(false)`]{@link #sendOmniMode}                  |\n   * | `omnimodeon`         | 125  | [`sendOmniMode(true)`]{@link #sendOmniMode}                   |\n   * | `monomodeon`         | 126  | [`sendPolyphonicMode("mono")`]{@link #sendPolyphonicMode}     |\n   * | `polymodeon`         | 127  | [`sendPolyphonicMode("poly")`]{@link #sendPolyphonicMode}     |\n   *\n   * **Note**: as you can see above, to make it easier, all channel mode messages also have a matching\n   * helper method.\n   *\n   * It should be noted that, per the MIDI specification, only `localcontrol` and `monomodeon` may\n   * require a value that\'s not zero. For that reason, the `value` parameter is optional and\n   * defaults to 0.\n   *\n   * @param {number|string} command The numerical identifier of the channel mode message (integer\n   * between `120` and `127`) or its name as a string.\n   *\n   * @param {number} [value=0] The value to send (integer between `0` - `127`).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendChannelMode(e, t = 0, n = {}) {\n    if (typeof e == "string" && (e = i.CHANNEL_MODE_MESSAGES[e]), l.validation) {\n      if (e === void 0)\n        throw new TypeError("Invalid channel mode message name or number.");\n      if (isNaN(e) || !(e >= 120 && e <= 127))\n        throw new TypeError("Invalid channel mode message number.");\n      if (isNaN(parseInt(t)) || t < 0 || t > 127)\n        throw new RangeError("Value must be an integer between 0 and 127.");\n    }\n    return this.send(\n      [\n        (i.CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1),\n        e,\n        t\n      ],\n      { time: o.toTimestamp(n.time) }\n    ), this;\n  }\n  /**\n   * Sets OMNI mode to `"on"` or `"off"`. MIDI\'s OMNI mode causes the instrument to respond to\n   * messages from all channels.\n   *\n   * It should be noted that support for OMNI mode is not as common as it used to be.\n   *\n   * @param [state=true] {boolean} Whether to activate OMNI mode (`true`) or not (`false`).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Invalid channel mode message name.\n   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.\n   * @throws {RangeError} Value must be an integer between 0 and 127.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendOmniMode(e, t = {}) {\n    return e === void 0 || e ? this.sendChannelMode("omnimodeon", 0, t) : this.sendChannelMode("omnimodeoff", 0, t), this;\n  }\n  /**\n   * Sends a MIDI **channel aftertouch** message. For key-specific aftertouch, you should instead\n   * use [`sendKeyAftertouch()`]{@link #sendKeyAftertouch}.\n   *\n   * @param [pressure] {number} The pressure level (between `0` and `1`). If the `rawValue` option\n   * is set to `true`, the pressure can be defined by using an integer between `0` and `127`.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   * @throws RangeError Invalid channel aftertouch value.\n   */\n  sendChannelAftertouch(e, t = {}) {\n    if (l.validation) {\n      if (isNaN(parseFloat(e)))\n        throw new RangeError("Invalid channel aftertouch value.");\n      if (t.rawValue) {\n        if (!(e >= 0 && e <= 127 && Number.isInteger(e)))\n          throw new RangeError(\n            "Channel aftertouch raw value must be an integer between 0 and 127."\n          );\n      } else if (!(e >= 0 && e <= 1))\n        throw new RangeError("Channel aftertouch value must be a float between 0 and 1.");\n    }\n    return t.rawValue || (e = o.fromFloatTo7Bit(e)), this.send(\n      [\n        (i.CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1),\n        Math.round(e)\n      ],\n      { time: o.toTimestamp(t.time) }\n    ), this;\n  }\n  /**\n   * Sends a **master tuning** message. The value is decimal and must be larger than -65 semitones\n   * and smaller than 64 semitones.\n   *\n   * Because of the way the MIDI specification works, the decimal portion of the value will be\n   * encoded with a resolution of 14bit. The integer portion must be between -64 and 63\n   * inclusively. This function actually generates two MIDI messages: a **Master Coarse Tuning** and\n   * a **Master Fine Tuning** RPN messages.\n   *\n   * @param [value=0.0] {number} The desired decimal adjustment value in semitones (-65 < x < 64)\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller\n   * than 64.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendMasterTuning(e, t = {}) {\n    if (e = parseFloat(e) || 0, l.validation && !(e > -65 && e < 64))\n      throw new RangeError(\n        "The value must be a decimal number larger than -65 and smaller than 64."\n      );\n    let n = Math.floor(e) + 64, r = e - Math.floor(e);\n    r = Math.round((r + 1) / 2 * 16383);\n    let s = r >> 7 & 127, d = r & 127;\n    return this.sendRpnValue("channelcoarsetuning", n, t), this.sendRpnValue("channelfinetuning", [s, d], t), this;\n  }\n  /**\n   * Sends a **modulation depth range** message to adjust the depth of the modulation wheel\'s range.\n   * The range can be specified with the `semitones` parameter, the `cents` parameter or by\n   * specifying both parameters at the same time.\n   *\n   * @param {number} semitones The desired adjustment value in semitones (integer between 0 and\n   * 127).\n   *\n   * @param {number} [cents=0] The desired adjustment value in cents (integer between 0 and 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendModulationRange(e, t, n = {}) {\n    if (l.validation) {\n      if (!Number.isInteger(e) || !(e >= 0 && e <= 127))\n        throw new RangeError("The semitones value must be an integer between 0 and 127.");\n      if (t != null && (!Number.isInteger(t) || !(t >= 0 && t <= 127)))\n        throw new RangeError("If specified, the cents value must be an integer between 0 and 127.");\n    }\n    return t >= 0 && t <= 127 || (t = 0), this.sendRpnValue("modulationrange", [e, t], n), this;\n  }\n  /**\n   * Sets a non-registered parameter (NRPN) to the specified value. The NRPN is selected by passing\n   * in a two-position array specifying the values of the two control bytes. The value is specified\n   * by passing in a single integer (most cases) or an array of two integers.\n   *\n   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way\n   * they see fit. For example, according to the Roland GS specification, you can control the\n   * **vibrato rate** using NRPN (1, 8). Therefore, to set the **vibrato rate** value to **123** you\n   * would use:\n   *\n   * ```js\n   * WebMidi.outputs[0].channels[0].sendNrpnValue([1, 8], 123);\n   * ```\n   *\n   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you\n   * would use a 2-position array. For example, for its **ClockBPM** parameter (2, 63), Novation\n   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the\n   * value to send was 10, you could use:\n   *\n   * ```js\n   * WebMidi.outputs[0].channels[0].sendNrpnValue([2, 63], [0, 10]);\n   * ```\n   *\n   * For further implementation details, refer to the manufacturer\'s documentation.\n   *\n   * @param nrpn {number[]} A two-position array specifying the two control bytes (0x63,\n   * 0x62) that identify the non-registered parameter.\n   *\n   * @param [data=[]] {number|number[]} An integer or an array of integers with a length of 1 or 2\n   * specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The control value must be between 0 and 127.\n   * @throws {RangeError} The msb value must be between 0 and 127\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendNrpnValue(e, t, n = {}) {\n    if (t = [].concat(t), l.validation) {\n      if (!Array.isArray(e) || !Number.isInteger(e[0]) || !Number.isInteger(e[1]))\n        throw new TypeError("The specified NRPN is invalid.");\n      if (!(e[0] >= 0 && e[0] <= 127))\n        throw new RangeError("The first byte of the NRPN must be between 0 and 127.");\n      if (!(e[1] >= 0 && e[1] <= 127))\n        throw new RangeError("The second byte of the NRPN must be between 0 and 127.");\n      t.forEach((r) => {\n        if (!(r >= 0 && r <= 127))\n          throw new RangeError("The data bytes of the NRPN must be between 0 and 127.");\n      });\n    }\n    return this._selectNonRegisteredParameter(e, n), this._setCurrentParameter(t, n), this._deselectNonRegisteredParameter(n), this;\n  }\n  /**\n   * Sends a MIDI **pitch bend** message at the scheduled time. The resulting bend is relative to\n   * the pitch bend range that has been defined. The range can be set with\n   * [`sendPitchBendRange()`]{@link #sendPitchBendRange}. So, for example, if the pitch\n   * bend range has been set to 12 semitones, using a bend value of -1 will bend the note 1 octave\n   * below its nominal value.\n   *\n   * @param {number|number[]} [value] The intensity of the bend (between -1.0 and 1.0). A value of\n   * zero means no bend. If the `rawValue` option is set to `true`, the intensity of the bend can be\n   * defined by either using a single integer between 0 and 127 (MSB) or an array of two integers\n   * between 0 and 127 representing, respectively, the MSB (most significant byte) and the LSB\n   * (least significant byte). The MSB is expressed in semitones with `64` meaning no bend. A value\n   * lower than `64` bends downwards while a value higher than `64` bends upwards. The LSB is\n   * expressed in cents (1/100 of a semitone). An LSB of `64` also means no bend.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered as a float between -1.0 and 1.0 (default) or as raw integer between 0 and 127 (or\n   * an array of 2 integers if using both MSB and LSB).\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendPitchBend(e, t = {}) {\n    if (l.validation)\n      if (t.rawValue && Array.isArray(e)) {\n        if (!(e[0] >= 0 && e[0] <= 127))\n          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");\n        if (!(e[1] >= 0 && e[1] <= 127))\n          throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.");\n      } else if (t.rawValue && !Array.isArray(e)) {\n        if (!(e >= 0 && e <= 127))\n          throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");\n      } else {\n        if (isNaN(e) || e === null)\n          throw new RangeError("Invalid pitch bend value.");\n        if (!(e >= -1 && e <= 1))\n          throw new RangeError("The pitch bend value must be a float between -1 and 1.");\n      }\n    let n = 0, r = 0;\n    if (t.rawValue && Array.isArray(e))\n      n = e[0], r = e[1];\n    else if (t.rawValue && !Array.isArray(e))\n      n = e;\n    else {\n      const s = o.fromFloatToMsbLsb((e + 1) / 2);\n      n = s.msb, r = s.lsb;\n    }\n    return this.send(\n      [\n        (i.CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1),\n        r,\n        n\n      ],\n      { time: o.toTimestamp(t.time) }\n    ), this;\n  }\n  /**\n   * Sends a **pitch bend range** message at the scheduled time to adjust the range used by the\n   * pitch bend lever. The range is specified by using the `semitones` and `cents` parameters. For\n   * example, setting the `semitones` parameter to `12` means that the pitch bend range will be 12\n   * semitones above and below the nominal pitch.\n   *\n   * @param semitones {number} The desired adjustment value in semitones (between 0 and 127). While\n   * nothing imposes that in the specification, it is very common for manufacturers to limit the\n   * range to 2 octaves (-12 semitones to 12 semitones).\n   *\n   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The semitones value must be an integer between 0 and 127.\n   * @throws {RangeError} The cents value must be an integer between 0 and 127.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendPitchBendRange(e, t, n = {}) {\n    if (l.validation) {\n      if (!Number.isInteger(e) || !(e >= 0 && e <= 127))\n        throw new RangeError("The semitones value must be an integer between 0 and 127.");\n      if (!Number.isInteger(t) || !(t >= 0 && t <= 127))\n        throw new RangeError("The cents value must be an integer between 0 and 127.");\n    }\n    return this.sendRpnValue("pitchbendrange", [e, t], n), this;\n  }\n  /**\n   * Sends a MIDI **program change** message at the scheduled time.\n   *\n   * @param [program=1] {number} The MIDI patch (program) number (integer between `0` and `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Failed to execute \'send\' on \'MIDIOutput\': The value at index 1 is greater\n   * than 0xFF.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   *\n   */\n  sendProgramChange(e, t = {}) {\n    if (e = parseInt(e) || 0, l.validation && !(e >= 0 && e <= 127))\n      throw new RangeError("The program number must be between 0 and 127.");\n    return this.send(\n      [\n        (i.CHANNEL_MESSAGES.programchange << 4) + (this.number - 1),\n        e\n      ],\n      { time: o.toTimestamp(t.time) }\n    ), this;\n  }\n  /**\n   * Sets the specified MIDI registered parameter to the desired value. The value is defined with\n   * up to two bytes of data (msb, lsb) that each can go from 0 to 127.\n   *\n   * MIDI\n   * [registered parameters](https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)\n   * extend the original list of control change messages. The MIDI 1.0 specification lists only a\n   * limited number of them:\n   *\n   * | Numbers      | Function                 |\n   * |--------------|--------------------------|\n   * | (0x00, 0x00) | `pitchbendrange`         |\n   * | (0x00, 0x01) | `channelfinetuning`      |\n   * | (0x00, 0x02) | `channelcoarsetuning`    |\n   * | (0x00, 0x03) | `tuningprogram`          |\n   * | (0x00, 0x04) | `tuningbank`             |\n   * | (0x00, 0x05) | `modulationrange`        |\n   * | (0x3D, 0x00) | `azimuthangle`           |\n   * | (0x3D, 0x01) | `elevationangle`         |\n   * | (0x3D, 0x02) | `gain`                   |\n   * | (0x3D, 0x03) | `distanceratio`          |\n   * | (0x3D, 0x04) | `maximumdistance`        |\n   * | (0x3D, 0x05) | `maximumdistancegain`    |\n   * | (0x3D, 0x06) | `referencedistanceratio` |\n   * | (0x3D, 0x07) | `panspreadangle`         |\n   * | (0x3D, 0x08) | `rollangle`              |\n   *\n   * Note that the **Tuning Program** and **Tuning Bank** parameters are part of the *MIDI Tuning\n   * Standard*, which is not widely implemented.\n   *\n   * @param rpn {string|number[]} A string identifying the parameter\'s name (see above) or a\n   * two-position array specifying the two control bytes (e.g. `[0x65, 0x64]`) that identify the\n   * registered parameter.\n   *\n   * @param [data=[]] {number|number[]} An single integer or an array of integers with a maximum\n   * length of 2 specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendRpnValue(e, t, n = {}) {\n    if (Array.isArray(e) || (e = i.REGISTERED_PARAMETERS[e]), l.validation) {\n      if (!Number.isInteger(e[0]) || !Number.isInteger(e[1]))\n        throw new TypeError("The specified NRPN is invalid.");\n      if (!(e[0] >= 0 && e[0] <= 127))\n        throw new RangeError("The first byte of the RPN must be between 0 and 127.");\n      if (!(e[1] >= 0 && e[1] <= 127))\n        throw new RangeError("The second byte of the RPN must be between 0 and 127.");\n      [].concat(t).forEach((r) => {\n        if (!(r >= 0 && r <= 127))\n          throw new RangeError("The data bytes of the RPN must be between 0 and 127.");\n      });\n    }\n    return this._selectRegisteredParameter(e, n), this._setCurrentParameter(t, n), this._deselectRegisteredParameter(n), this;\n  }\n  /**\n   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * @param value {number} The desired tuning bank (integer between `0` and `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The bank value must be between 0 and 127.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendTuningBank(e, t = {}) {\n    if (l.validation && (!Number.isInteger(e) || !(e >= 0 && e <= 127)))\n      throw new RangeError("The tuning bank number must be between 0 and 127.");\n    return this.sendRpnValue("tuningbank", e, t), this;\n  }\n  /**\n   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * @param value {number} The desired tuning program (integer between `0` and `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The program value must be between 0 and 127.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendTuningProgram(e, t = {}) {\n    if (l.validation && (!Number.isInteger(e) || !(e >= 0 && e <= 127)))\n      throw new RangeError("The tuning program number must be between 0 and 127.");\n    return this.sendRpnValue("tuningprogram", e, t), this;\n  }\n  /**\n   * Turns local control on or off. Local control is usually enabled by default. If you disable it,\n   * the instrument will no longer trigger its own sounds. It will only send the MIDI messages to\n   * its out port.\n   *\n   * @param [state=false] {boolean} Whether to activate local control (`true`) or disable it\n   * (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendLocalControl(e, t = {}) {\n    return e ? this.sendChannelMode("localcontrol", 127, t) : this.sendChannelMode("localcontrol", 0, t);\n  }\n  /**\n   * Sends an **all notes off** channel mode message. This will make all currently playing notes\n   * fade out just as if their key had been released. This is different from the\n   * [`sendAllSoundOff()`]{@link #sendAllSoundOff} method which mutes all sounds immediately.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendAllNotesOff(e = {}) {\n    return this.sendChannelMode("allnotesoff", 0, e);\n  }\n  /**\n   * Sends an **all sound off** channel mode message. This will silence all sounds playing on that\n   * channel but will not prevent new sounds from being triggered.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendAllSoundOff(e = {}) {\n    return this.sendChannelMode("allsoundoff", 0, e);\n  }\n  /**\n   * Sends a **reset all controllers** channel mode message. This resets all controllers, such as\n   * the pitch bend, to their default value.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendResetAllControllers(e = {}) {\n    return this.sendChannelMode("resetallcontrollers", 0, e);\n  }\n  /**\n   * Sets the polyphonic mode. In `"poly"` mode (usually the default), multiple notes can be played\n   * and heard at the same time. In `"mono"` mode, only one note will be heard at once even if\n   * multiple notes are being played.\n   *\n   * @param {string} [mode=poly] The mode to use: `"mono"` or `"poly"`.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {OutputChannel} Returns the `OutputChannel` object so methods can be chained.\n   */\n  sendPolyphonicMode(e, t = {}) {\n    return e === "mono" ? this.sendChannelMode("monomodeon", 0, t) : this.sendChannelMode("polymodeon", 0, t);\n  }\n  /**\n   * An integer to offset the reported octave of outgoing note-specific messages (`noteon`,\n   * `noteoff` and `keyaftertouch`). By default, middle C (MIDI note number 60) is placed on the 4th\n   * octave (C4).\n   *\n   * Note that this value is combined with the global offset value defined in\n   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) and with the parent value defined in\n   * [`Output.octaveOffset`]{@link Output#octaveOffset}.\n   *\n   * @type {number}\n   *\n   * @since 3.0\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(e) {\n    if (this.validation && (e = parseInt(e), isNaN(e)))\n      throw new TypeError("The \'octaveOffset\' property must be an integer.");\n    this._octaveOffset = e;\n  }\n  /**\n   * The parent [`Output`]{@link Output} this channel belongs to.\n   * @type {Output}\n   * @since 3.0\n   */\n  get output() {\n    return this._output;\n  }\n  /**\n   * This channel\'s MIDI number (`1` - `16`).\n   * @type {number}\n   * @since 3.0\n   */\n  get number() {\n    return this._number;\n  }\n}\n/**\n * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).\n * A port is made available by a MIDI device. A MIDI device can advertise several input and output\n * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)\n * property.\n *\n * The `Output` object is automatically instantiated by the library according to the host\'s MIDI\n * subsystem and should not be directly instantiated.\n *\n * You can access all available `Output` objects by referring to the\n * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as\n * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or\n * [`WebMidi.getOutputById()`](WebMidi#getOutputById).\n *\n * @fires Output#opened\n * @fires Output#disconnected\n * @fires Output#closed\n *\n * @extends EventEmitter\n * @license Apache-2.0\n */\nclass I extends E {\n  /**\n   * Creates an `Output` object.\n   *\n   * @param {MIDIOutput} midiOutput [`MIDIOutput`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIOutput)\n   * object as provided by the MIDI subsystem.\n   */\n  constructor(e) {\n    super(), this._midiOutput = e, this._octaveOffset = 0, this.channels = [];\n    for (let t = 1; t <= 16; t++) this.channels[t] = new J(this, t);\n    this._midiOutput.onstatechange = this._onStateChange.bind(this);\n  }\n  /**\n   * Destroys the `Output`. All listeners are removed, all channels are destroyed and the MIDI\n   * subsystem is unlinked.\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    this.removeListener(), this.channels.forEach((e) => e.destroy()), this.channels = [], this._midiOutput && (this._midiOutput.onstatechange = null), await this.close(), this._midiOutput = null;\n  }\n  /**\n   * @private\n   */\n  _onStateChange(e) {\n    let t = {\n      timestamp: l.time\n    };\n    e.port.connection === "open" ? (t.type = "opened", t.target = this, t.port = t.target, this.emit("opened", t)) : e.port.connection === "closed" && e.port.state === "connected" ? (t.type = "closed", t.target = this, t.port = t.target, this.emit("closed", t)) : e.port.connection === "closed" && e.port.state === "disconnected" ? (t.type = "disconnected", t.port = {\n      connection: e.port.connection,\n      id: e.port.id,\n      manufacturer: e.port.manufacturer,\n      name: e.port.name,\n      state: e.port.state,\n      type: e.port.type\n    }, this.emit("disconnected", t)) : e.port.connection === "pending" && e.port.state === "disconnected" || console.warn("This statechange event was not caught:", e.port.connection, e.port.state);\n  }\n  /**\n   * Opens the output for usage. When the library is enabled, all ports are automatically opened.\n   * This method is only useful for ports that have been manually closed.\n   *\n   * @returns {Promise<Output>} The promise is fulfilled with the `Output` object.\n   */\n  async open() {\n    try {\n      return await this._midiOutput.open(), Promise.resolve(this);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Closes the output connection. When an output is closed, it cannot be used to send MIDI messages\n   * until the output is opened again by calling [`open()`]{@link #open}. You can check\n   * the connection status by looking at the [`connection`]{@link #connection} property.\n   *\n   * @returns {Promise<void>}\n   */\n  async close() {\n    this._midiOutput ? await this._midiOutput.close() : await Promise.resolve();\n  }\n  /**\n   * Sends a MIDI message on the MIDI output port. If no time is specified, the message will be\n   * sent immediately. The message should be an array of 8 bit unsigned integers (0-225), a\n   * [`Uint8Array`]{@link https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}\n   * object or a [`Message`](Message) object.\n   *\n   * It is usually not necessary to use this method directly as you can use one of the simpler\n   * helper methods such as [`playNote()`](#playNote), [`stopNote()`](#stopNote),\n   * [`sendControlChange()`](#sendControlChange), etc.\n   *\n   * Details on the format of MIDI messages are available in the summary of\n   * [MIDI messages]{@link https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message}\n   * from the MIDI Manufacturers Association.\n   *\n   * @param message {number[]|Uint8Array|Message} An array of 8bit unsigned integers, a `Uint8Array`\n   * object (not available in Node.js) containing the message bytes or a `Message` object.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The first byte (status) must be an integer between 128 and 255.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @license Apache-2.0\n   */\n  send(e, t = { time: 0 }, n = 0) {\n    if (e instanceof U && (e = o.isNode ? e.data : e.rawData), e instanceof Uint8Array && o.isNode && (e = Array.from(e)), l.validation) {\n      if (!Array.isArray(e) && !(e instanceof Uint8Array) && (e = [e], Array.isArray(t) && (e = e.concat(t)), t = isNaN(n) ? { time: 0 } : { time: n }), !(parseInt(e[0]) >= 128 && parseInt(e[0]) <= 255))\n        throw new RangeError("The first byte (status) must be an integer between 128 and 255.");\n      e.slice(1).forEach((r) => {\n        if (r = parseInt(r), !(r >= 0 && r <= 255))\n          throw new RangeError("Data bytes must be integers between 0 and 255.");\n      }), t || (t = { time: 0 });\n    }\n    return this._midiOutput.send(e, o.toTimestamp(t.time)), this;\n  }\n  /**\n   * Sends a MIDI [**system exclusive**]{@link\n    * https://www.midi.org/specifications-old/item/table-4-universal-system-exclusive-messages}\n   * (*sysex*) message. There are two categories of system exclusive messages: manufacturer-specific\n   * messages and universal messages. Universal messages are further divided into three subtypes:\n   *\n   *   * Universal non-commercial (for research and testing): `0x7D`\n   *   * Universal non-realtime: `0x7E`\n   *   * Universal realtime: `0x7F`\n   *\n   * The method\'s first parameter (`identification`) identifies the type of message. If the value of\n   * `identification` is `0x7D` (125), `0x7E` (126) or `0x7F` (127), the message will be identified\n   * as a **universal non-commercial**, **universal non-realtime** or **universal realtime** message\n   * (respectively).\n   *\n   * If the `identification` value is an array or an integer between 0 and 124, it will be used to\n   * identify the manufacturer targeted by the message. The *MIDI Manufacturers Association*\n   * maintains a full list of\n   * [Manufacturer ID Numbers](https://www.midi.org/specifications-old/item/manufacturer-id-numbers).\n   *\n   * The `data` parameter should only contain the data of the message. When sending out the actual\n   * MIDI message, WEBMIDI.js will automatically prepend the data with the **sysex byte** (`0xF0`)\n   * and the identification byte(s). It will also automatically terminate the message with the\n   * **sysex end byte** (`0xF7`).\n   *\n   * To use the `sendSysex()` method, system exclusive message support must have been enabled. To\n   * do so, you must set the `sysex` option to `true` when calling\n   * [`WebMidi.enable()`]{@link WebMidi#enable}:\n   *\n   * ```js\n   * WebMidi.enable({sysex: true})\n   *   .then(() => console.log("System exclusive messages are enabled");\n   * ```\n   *\n   * ##### Examples of manufacturer-specific system exclusive messages\n   *\n   * If you want to send a sysex message to a Korg device connected to the first output, you would\n   * use the following code:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex(0x42, [0x1, 0x2, 0x3, 0x4, 0x5]);\n   * ```\n   * In this case `0x42` is the ID of the manufacturer (Korg) and `[0x1, 0x2, 0x3, 0x4, 0x5]` is the\n   * data being sent.\n   *\n   * The parameters can be specified using any number notation (decimal, hex, binary, etc.).\n   * Therefore, the code above is equivalent to this code:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex(66, [1, 2, 3, 4, 5]);\n   * ```\n   *\n   * Some manufacturers are identified using 3 bytes. In this case, you would use a 3-position array\n   * as the first parameter. For example, to send the same sysex message to a\n   * *Native Instruments* device:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex([0x00, 0x21, 0x09], [0x1, 0x2, 0x3, 0x4, 0x5]);\n   * ```\n   *\n   * There is no limit for the length of the data array. However, it is generally suggested to keep\n   * system exclusive messages to 64Kb or less.\n   *\n   * ##### Example of universal system exclusive message\n   *\n   * If you want to send a universal sysex message, simply assign the correct identification number\n   * in the first parameter. Number `0x7D` (125) is for non-commercial, `0x7E` (126) is for\n   * non-realtime and `0x7F` (127) is for realtime.\n   *\n   * So, for example, if you wanted to send an identity request non-realtime message (`0x7E`), you\n   * could use the following:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendSysex(0x7E, [0x7F, 0x06, 0x01]);\n   * ```\n   *\n   * For more details on the format of universal messages, consult the list of\n   * [universal sysex messages](https://www.midi.org/specifications-old/item/table-4-universal-system-exclusive-messages).\n   *\n   * @param {number|number[]} identification An unsigned integer or an array of three unsigned\n   * integers between `0` and `127` that either identify the manufacturer or sets the message to be\n   * a **universal non-commercial message** (`0x7D`), a **universal non-realtime message** (`0x7E`)\n   * or a **universal realtime message** (`0x7F`). The *MIDI Manufacturers Association* maintains a\n   * full list of\n   * [Manufacturer ID Numbers](https://www.midi.org/specifications-old/item/manufacturer-id-numbers).\n   *\n   * @param {number[]|Uint8Array} [data] A `Uint8Array` or an array of unsigned integers between `0`\n   * and `127`. This is the data you wish to transfer.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {DOMException} Failed to execute \'send\' on \'MIDIOutput\': System exclusive message is\n   * not allowed.\n   *\n   * @throws {TypeError} Failed to execute \'send\' on \'MIDIOutput\': The value at index x is greater\n   * than 0xFF.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendSysex(e, t = [], n = {}) {\n    if (e = [].concat(e), t instanceof Uint8Array) {\n      const r = new Uint8Array(1 + e.length + t.length + 1);\n      r[0] = i.SYSTEM_MESSAGES.sysex, r.set(Uint8Array.from(e), 1), r.set(t, 1 + e.length), r[r.length - 1] = i.SYSTEM_MESSAGES.sysexend, this.send(r, { time: n.time });\n    } else {\n      const r = e.concat(t, i.SYSTEM_MESSAGES.sysexend);\n      this.send([i.SYSTEM_MESSAGES.sysex].concat(r), { time: n.time });\n    }\n    return this;\n  }\n  /**\n   * Clears all MIDI messages that have been queued and scheduled but not yet sent.\n   *\n   * **Warning**: this method is defined in the\n   * [Web MIDI API specification](https://www.w3.org/TR/webmidi/#MIDIOutput) but has not been\n   * implemented by all browsers yet. You can follow\n   * [this issue](https://github.com/djipco/webmidi/issues/52) for more info.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  clear() {\n    return this._midiOutput.clear ? this._midiOutput.clear() : l.validation && console.warn(\n      "The \'clear()\' method has not yet been implemented in your environment."\n    ), this;\n  }\n  /**\n   * Sends a MIDI **timecode quarter frame** message. Please note that no processing is being done\n   * on the data. It is up to the developer to format the data according to the\n   * [MIDI Timecode](https://en.wikipedia.org/wiki/MIDI_timecode) format.\n   *\n   * @param value {number} The quarter frame message content (integer between 0 and 127).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendTimecodeQuarterFrame(e, t = {}) {\n    if (l.validation && (e = parseInt(e), isNaN(e) || !(e >= 0 && e <= 127)))\n      throw new RangeError("The value must be an integer between 0 and 127.");\n    return this.send(\n      [\n        i.SYSTEM_MESSAGES.timecode,\n        e\n      ],\n      { time: t.time }\n    ), this;\n  }\n  /**\n   * Sends a **song position** MIDI message. The value is expressed in MIDI beats (between `0` and\n   * `16383`) which are 16th note. Position `0` is always the start of the song.\n   *\n   * @param {number} [value=0] The MIDI beat to cue to (integer between `0` and `16383`).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendSongPosition(e = 0, t = {}) {\n    e = Math.floor(e) || 0;\n    var n = e >> 7 & 127, r = e & 127;\n    return this.send(\n      [\n        i.SYSTEM_MESSAGES.songposition,\n        n,\n        r\n      ],\n      { time: t.time }\n    ), this;\n  }\n  /**\n   * Sends a **song select** MIDI message.\n   *\n   * @param {number} [value=0] The number of the song to select (integer between `0` and `127`).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws The song number must be between 0 and 127.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendSongSelect(e = 0, t = {}) {\n    if (l.validation && (e = parseInt(e), isNaN(e) || !(e >= 0 && e <= 127)))\n      throw new RangeError("The program value must be between 0 and 127");\n    return this.send(\n      [\n        i.SYSTEM_MESSAGES.songselect,\n        e\n      ],\n      { time: t.time }\n    ), this;\n  }\n  /**\n   * Sends a MIDI **tune request** real-time message.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendTuneRequest(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.tunerequest],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * Sends a MIDI **clock** real-time message. According to the standard, there are 24 MIDI clocks\n   * for every quarter note.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendClock(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.clock],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * Sends a **start** real-time message. A MIDI Start message starts the playback of the current\n   * song at beat 0. To start playback elsewhere in the song, use the\n   * [`sendContinue()`]{@link #sendContinue} method.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendStart(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.start],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * Sends a **continue** real-time message. This resumes song playback where it was previously\n   * stopped or where it was last cued with a song position message. To start playback from the\n   * start, use the [`sendStart()`]{@link Output#sendStart}` method.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendContinue(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.continue],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * Sends a **stop** real-time message. This tells the device connected to this output to stop\n   * playback immediately (or at the scheduled time, if specified).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendStop(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.stop],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * Sends an **active sensing** real-time message. This tells the device connected to this port\n   * that the connection is still good. Active sensing messages are often sent every 300 ms if there\n   * was no other activity on the MIDI port.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendActiveSensing(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.activesensing],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * Sends a **reset** real-time message. This tells the device connected to this output that it\n   * should reset itself to a default state.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendReset(e = {}) {\n    return this.send(\n      [i.SYSTEM_MESSAGES.reset],\n      { time: e.time }\n    ), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  sendTuningRequest(e = {}) {\n    return l.validation && console.warn(\n      "The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."\n    ), this.sendTuneRequest(e);\n  }\n  /**\n   * Sends a MIDI **key aftertouch** message to the specified channel(s) at the scheduled time. This\n   * is a key-specific aftertouch. For a channel-wide aftertouch message, use\n   * [`setChannelAftertouch()`]{@link #setChannelAftertouch}.\n   *\n   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) for which you are sending\n   * an aftertouch value. The notes can be specified by using a MIDI note number (`0` - `127`), a\n   * [`Note`](Note) object, a note identifier (e.g. `C3`, `G#4`, `F-1`, `Db7`) or an array of the\n   * previous types. When using a note identifier, octave range must be between `-1` and `9`. The\n   * lowest note is `C-1` (MIDI note number `0`) and the highest note is `G9` (MIDI note number\n   * `127`).\n   *\n   * @param [pressure=0.5] {number} The pressure level (between 0 and 1). An invalid pressure value\n   * will silently trigger the default behaviour. If the `rawValue` option is set to `true`, the\n   * pressure can be defined by using an integer between 0 and 127.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendKeyAftertouch(e, t, n = {}) {\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((r) => {\n      this.channels[r].sendKeyAftertouch(e, t, n);\n    }), this;\n  }\n  /**\n   * Sends a MIDI **control change** message to the specified channel(s) at the scheduled time. The\n   * control change message to send can be specified numerically (0-127) or by using one of the\n   * following common names:\n   *\n   * | Number | Name                          |\n   * |--------|-------------------------------|\n   * | 0      |`bankselectcoarse`             |\n   * | 1      |`modulationwheelcoarse`        |\n   * | 2      |`breathcontrollercoarse`       |\n   * | 4      |`footcontrollercoarse`         |\n   * | 5      |`portamentotimecoarse`         |\n   * | 6      |`dataentrycoarse`              |\n   * | 7      |`volumecoarse`                 |\n   * | 8      |`balancecoarse`                |\n   * | 10     |`pancoarse`                    |\n   * | 11     |`expressioncoarse`             |\n   * | 12     |`effectcontrol1coarse`         |\n   * | 13     |`effectcontrol2coarse`         |\n   * | 18     |`generalpurposeslider3`        |\n   * | 19     |`generalpurposeslider4`        |\n   * | 32     |`bankselectfine`               |\n   * | 33     |`modulationwheelfine`          |\n   * | 34     |`breathcontrollerfine`         |\n   * | 36     |`footcontrollerfine`           |\n   * | 37     |`portamentotimefine`           |\n   * | 38     |`dataentryfine`                |\n   * | 39     |`volumefine`                   |\n   * | 40     |`balancefine`                  |\n   * | 42     |`panfine`                      |\n   * | 43     |`expressionfine`               |\n   * | 44     |`effectcontrol1fine`           |\n   * | 45     |`effectcontrol2fine`           |\n   * | 64     |`holdpedal`                    |\n   * | 65     |`portamento`                   |\n   * | 66     |`sustenutopedal`               |\n   * | 67     |`softpedal`                    |\n   * | 68     |`legatopedal`                  |\n   * | 69     |`hold2pedal`                   |\n   * | 70     |`soundvariation`               |\n   * | 71     |`resonance`                    |\n   * | 72     |`soundreleasetime`             |\n   * | 73     |`soundattacktime`              |\n   * | 74     |`brightness`                   |\n   * | 75     |`soundcontrol6`                |\n   * | 76     |`soundcontrol7`                |\n   * | 77     |`soundcontrol8`                |\n   * | 78     |`soundcontrol9`                |\n   * | 79     |`soundcontrol10`               |\n   * | 80     |`generalpurposebutton1`        |\n   * | 81     |`generalpurposebutton2`        |\n   * | 82     |`generalpurposebutton3`        |\n   * | 83     |`generalpurposebutton4`        |\n   * | 91     |`reverblevel`                  |\n   * | 92     |`tremololevel`                 |\n   * | 93     |`choruslevel`                  |\n   * | 94     |`celestelevel`                 |\n   * | 95     |`phaserlevel`                  |\n   * | 96     |`dataincrement`                |\n   * | 97     |`datadecrement`                |\n   * | 98     |`nonregisteredparametercoarse` |\n   * | 99     |`nonregisteredparameterfine`   |\n   * | 100    |`registeredparametercoarse`    |\n   * | 101    |`registeredparameterfine`      |\n   * | 120    |`allsoundoff`                  |\n   * | 121    |`resetallcontrollers`          |\n   * | 122    |`localcontrol`                 |\n   * | 123    |`allnotesoff`                  |\n   * | 124    |`omnimodeoff`                  |\n   * | 125    |`omnimodeon`                   |\n   * | 126    |`monomodeon`                   |\n   * | 127    |`polymodeon`                   |\n   *\n   * Note: as you can see above, not all control change message have a matching name. This does not\n   * mean you cannot use the others. It simply means you will need to use their number (`0` - `127`)\n   * instead of their name. While you can still use them, numbers `120` to `127` are usually\n   * reserved for *channel mode* messages. See [`sendChannelMode()`]{@link #sendChannelMode} method\n   * for more info.\n   *\n   * To view a list of all available **control change** messages, please consult [Table 3 - Control\n   * Change Messages](https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)\n   * from the MIDI specification.\n   *\n   * @param controller {number|string} The MIDI controller name or number (0-127).\n   *\n   * @param [value=0] {number} The value to send (0-127).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} Controller numbers must be between 0 and 127.\n   * @throws {RangeError} Invalid controller name.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendControlChange(e, t, n = {}, r = {}) {\n    if (l.validation && (Array.isArray(n) || Number.isInteger(n) || n === "all")) {\n      const s = n;\n      n = r, n.channels = s, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((s) => {\n      this.channels[s].sendControlChange(e, t, n);\n    }), this;\n  }\n  /**\n   * Sends a **pitch bend range** message to the specified channel(s) at the scheduled time so that\n   * they adjust the range used by their pitch bend lever. The range is specified by using the\n   * `semitones` and `cents` parameters. For example, setting the `semitones` parameter to `12`\n   * means that the pitch bend range will be 12 semitones above and below the nominal pitch.\n   *\n   * @param {number} [semitones=0] The desired adjustment value in semitones (between `0` and `127`).\n   * While nothing imposes that in the specification, it is very common for manufacturers to limit\n   * the range to 2 octaves (-12 semitones to 12 semitones).\n   *\n   * @param {number} [cents=0] The desired adjustment value in cents (integer between `0` and\n   * `127`).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The msb value must be between 0 and 127.\n   * @throws {RangeError} The lsb value must be between 0 and 127.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendPitchBendRange(e = 0, t = 0, n = {}) {\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((r) => {\n      this.channels[r].sendPitchBendRange(e, t, n);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setPitchBendRange(e = 0, t = 0, n = "all", r = {}) {\n    return l.validation && (console.warn(\n      "The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."\n    ), r.channels = n, r.channels === "all" && (r.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendPitchBendRange(e, t, r);\n  }\n  /**\n   * Sets the specified MIDI registered parameter to the desired value. The value is defined with\n   * up to two bytes of data (msb, lsb) that each can go from `0` to `127`.\n   *\n   * MIDI\n   * [registered parameters](https://www.midi.org/specifications-old/item/table-3-control-change-messages-data-bytes-2)\n   * extend the original list of control change messages. The MIDI 1.0 specification lists only a\n   * limited number of them:\n   *\n   * | Numbers      | Function                 |\n   * |--------------|--------------------------|\n   * | (0x00, 0x00) | `pitchbendrange`         |\n   * | (0x00, 0x01) | `channelfinetuning`      |\n   * | (0x00, 0x02) | `channelcoarsetuning`    |\n   * | (0x00, 0x03) | `tuningprogram`          |\n   * | (0x00, 0x04) | `tuningbank`             |\n   * | (0x00, 0x05) | `modulationrange`        |\n   * | (0x3D, 0x00) | `azimuthangle`           |\n   * | (0x3D, 0x01) | `elevationangle`         |\n   * | (0x3D, 0x02) | `gain`                   |\n   * | (0x3D, 0x03) | `distanceratio`          |\n   * | (0x3D, 0x04) | `maximumdistance`        |\n   * | (0x3D, 0x05) | `maximumdistancegain`    |\n   * | (0x3D, 0x06) | `referencedistanceratio` |\n   * | (0x3D, 0x07) | `panspreadangle`         |\n   * | (0x3D, 0x08) | `rollangle`              |\n   *\n   * Note that the `tuningprogram` and `tuningbank` parameters are part of the *MIDI Tuning\n   * Standard*, which is not widely implemented.\n   *\n   * @param parameter {string|number[]} A string identifying the parameter\'s name (see above) or a\n   * two-position array specifying the two control bytes (e.g. `[0x65, 0x64]`) that identify the\n   * registered parameter.\n   *\n   * @param [data=[]] {number|number[]} A single integer or an array of integers with a maximum\n   * length of 2 specifying the desired data.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendRpnValue(e, t, n = {}) {\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((r) => {\n      this.channels[r].sendRpnValue(e, t, n);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setRegisteredParameter(e, t = [], n = "all", r = {}) {\n    return l.validation && (console.warn(\n      "The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."\n    ), r.channels = n, r.channels === "all" && (r.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendRpnValue(e, t, r);\n  }\n  /**\n   * Sends a MIDI **channel aftertouch** message to the specified channel(s). For key-specific\n   * aftertouch, you should instead use [`setKeyAftertouch()`]{@link #setKeyAftertouch}.\n   *\n   * @param [pressure=0.5] {number} The pressure level (between `0` and `1`). An invalid pressure\n   * value will silently trigger the default behaviour. If the `rawValue` option is set to `true`,\n   * the pressure can be defined by using an integer between `0` and `127`.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered a float between `0` and `1.0` (default) or a raw integer between `0` and `127`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   * @since 3.0.0\n   */\n  sendChannelAftertouch(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendChannelAftertouch(e, t);\n    }), this;\n  }\n  /**\n   * Sends a MIDI **pitch bend** message to the specified channel(s) at the scheduled time.\n   *\n   * The resulting bend is relative to the pitch bend range that has been defined. The range can be\n   * set with [`sendPitchBendRange()`]{@link #sendPitchBendRange}. So, for example, if the pitch\n   * bend range has been set to 12 semitones, using a bend value of `-1` will bend the note 1 octave\n   * below its nominal value.\n   *\n   * @param {number|number[]} value The intensity of the bend (between `-1.0` and `1.0`). A value of\n   * `0` means no bend. If an invalid value is specified, the nearest valid value will be used\n   * instead. If the `rawValue` option is set to `true`, the intensity of the bend can be defined by\n   * either using a single integer between `0` and `127` (MSB) or an array of two integers between\n   * `0` and `127` representing, respectively, the MSB (most significant byte) and the LSB (least\n   * significant byte). The MSB is expressed in semitones with `64` meaning no bend. A value lower\n   * than `64` bends downwards while a value higher than `64` bends upwards. The LSB is expressed\n   * in cents (1/100 of a semitone). An LSB of `64` also means no bend.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {boolean} [options.rawValue=false] A boolean indicating whether the value should be\n   * considered as a float between `-1.0` and `1.0` (default) or as raw integer between `0` and\n   * 127` (or an array of 2 integers if using both MSB and LSB).\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendPitchBend(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendPitchBend(e, t);\n    }), this;\n  }\n  /**\n   * Sends a MIDI **program change** message to the specified channel(s) at the scheduled time.\n   *\n   * @param {number} [program=0] The MIDI patch (program) number (integer between `0` and `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Failed to execute \'send\' on \'MIDIOutput\': The value at index 1 is greater\n   * than 0xFF.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendProgramChange(e = 0, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendProgramChange(e, t);\n    }), this;\n  }\n  /**\n   * Sends a **modulation depth range** message to the specified channel(s) so that they adjust the\n   * depth of their modulation wheel\'s range. The range can be specified with the `semitones`\n   * parameter, the `cents` parameter or by specifying both parameters at the same time.\n   *\n   * @param [semitones=0] {number} The desired adjustment value in semitones (integer between\n   * 0 and 127).\n   *\n   * @param [cents=0] {number} The desired adjustment value in cents (integer between 0 and 127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The msb value must be between 0 and 127\n   * @throws {RangeError} The lsb value must be between 0 and 127\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendModulationRange(e, t, n = {}) {\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((r) => {\n      this.channels[r].sendModulationRange(e, t, n);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setModulationRange(e = 0, t = 0, n = "all", r = {}) {\n    return l.validation && (console.warn(\n      "The setModulationRange() method is deprecated. Use sendModulationRange() instead."\n    ), r.channels = n, r.channels === "all" && (r.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendModulationRange(e, t, r);\n  }\n  /**\n   * Sends a master tuning message to the specified channel(s). The value is decimal and must be\n   * larger than `-65` semitones and smaller than `64` semitones.\n   *\n   * Because of the way the MIDI specification works, the decimal portion of the value will be\n   * encoded with a resolution of 14bit. The integer portion must be between -64 and 63\n   * inclusively. This function actually generates two MIDI messages: a **Master Coarse Tuning** and\n   * a **Master Fine Tuning** RPN messages.\n   *\n   * @param [value=0.0] {number} The desired decimal adjustment value in semitones (-65 < x < 64)\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The value must be a decimal number between larger than -65 and smaller\n   * than 64.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendMasterTuning(e, t = {}) {\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((n) => {\n      this.channels[n].sendMasterTuning(e, t);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setMasterTuning(e, t = {}, n = {}) {\n    return l.validation && (console.warn(\n      "The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."\n    ), n.channels = t, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendMasterTuning(e, n);\n  }\n  /**\n   * Sets the MIDI tuning program to use. Note that the **Tuning Program** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * @param value {number} The desired tuning program (integer between `0` and `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The program value must be between 0 and 127.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendTuningProgram(e, t = {}) {\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((n) => {\n      this.channels[n].sendTuningProgram(e, t);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setTuningProgram(e, t = "all", n = {}) {\n    return l.validation && (console.warn(\n      "The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."\n    ), n.channels = t, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendTuningProgram(e, n);\n  }\n  /**\n   * Sets the MIDI tuning bank to use. Note that the **Tuning Bank** parameter is part of the\n   * *MIDI Tuning Standard*, which is not widely implemented.\n   *\n   * @param {number} [value=0] The desired tuning bank (integer between `0` and `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The bank value must be between 0 and 127.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendTuningBank(e = 0, t = {}) {\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((n) => {\n      this.channels[n].sendTuningBank(e, t);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setTuningBank(e, t = "all", n = {}) {\n    return l.validation && (console.warn(\n      "The setTuningBank() method is deprecated. Use sendTuningBank() instead."\n    ), n.channels = t, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendTuningBank(e, n);\n  }\n  /**\n   * Sends a MIDI **channel mode** message to the specified channel(s). The channel mode message to\n   * send can be specified numerically or by using one of the following common names:\n   *\n   * |  Type                |Number| Shortcut Method                                               |\n   * | ---------------------|------|-------------------------------------------------------------- |\n   * | `allsoundoff`        | 120  | [`sendAllSoundOff()`]{@link #sendAllSoundOff}                 |\n   * | `resetallcontrollers`| 121  | [`sendResetAllControllers()`]{@link #sendResetAllControllers} |\n   * | `localcontrol`       | 122  | [`sendLocalControl()`]{@link #sendLocalControl}               |\n   * | `allnotesoff`        | 123  | [`sendAllNotesOff()`]{@link #sendAllNotesOff}                 |\n   * | `omnimodeoff`        | 124  | [`sendOmniMode(false)`]{@link #sendOmniMode}                  |\n   * | `omnimodeon`         | 125  | [`sendOmniMode(true)`]{@link #sendOmniMode}                   |\n   * | `monomodeon`         | 126  | [`sendPolyphonicMode("mono")`]{@link #sendPolyphonicMode}     |\n   * | `polymodeon`         | 127  | [`sendPolyphonicMode("poly")`]{@link #sendPolyphonicMode}     |\n   *\n   * Note: as you can see above, to make it easier, all channel mode messages also have a matching\n   * helper method.\n   *\n   * It should also be noted that, per the MIDI specification, only `localcontrol` and `monomodeon`\n   * may require a value that\'s not zero. For that reason, the `value` parameter is optional and\n   * defaults to 0.\n   *\n   * @param {number|string} command The numerical identifier of the channel mode message (integer\n   * between 120-127) or its name as a string.\n   *\n   * @param {number} [value=0] The value to send (integer between 0-127).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Invalid channel mode message name.\n   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.\n   * @throws {RangeError} Value must be an integer between 0 and 127.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   */\n  sendChannelMode(e, t = 0, n = {}, r = {}) {\n    if (l.validation && (Array.isArray(n) || Number.isInteger(n) || n === "all")) {\n      const s = n;\n      n = r, n.channels = s, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((s) => {\n      this.channels[s].sendChannelMode(e, t, n);\n    }), this;\n  }\n  /**\n   * Sends an **all sound off** channel mode message. This will silence all sounds playing on that\n   * channel but will not prevent new sounds from being triggered.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output}\n   *\n   * @since 3.0.0\n   */\n  sendAllSoundOff(e = {}) {\n    return e.channels == null && (e.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(e.channels).forEach((t) => {\n      this.channels[t].sendAllSoundOff(e);\n    }), this;\n  }\n  /**\n   * Sends an **all notes off** channel mode message. This will make all currently playing notes\n   * fade out just as if their key had been released. This is different from the\n   * [`sendAllSoundOff()`]{@link #sendAllSoundOff} method which mutes all sounds immediately.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output}\n   *\n   * @since 3.0.0\n   */\n  sendAllNotesOff(e = {}) {\n    return e.channels == null && (e.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(e.channels).forEach((t) => {\n      this.channels[t].sendAllNotesOff(e);\n    }), this;\n  }\n  /**\n   * Sends a **reset all controllers** channel mode message. This resets all controllers, such as\n   * the pitch bend, to their default value.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output}\n   */\n  sendResetAllControllers(e = {}, t = {}) {\n    if (l.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {\n      const n = e;\n      e = t, e.channels = n, e.channels === "all" && (e.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return e.channels == null && (e.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(e.channels).forEach((n) => {\n      this.channels[n].sendResetAllControllers(e);\n    }), this;\n  }\n  /**\n   * Sets the polyphonic mode. In `poly` mode (usually the default), multiple notes can be played\n   * and heard at the same time. In `mono` mode, only one note will be heard at once even if\n   * multiple notes are being played.\n   *\n   * @param mode {string} The mode to use: `mono` or `poly`.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendPolyphonicMode(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendPolyphonicMode(e, t);\n    }), this;\n  }\n  /**\n   * Turns local control on or off. Local control is usually enabled by default. If you disable it,\n   * the instrument will no longer trigger its own sounds. It will only send the MIDI messages to\n   * its out port.\n   *\n   * @param [state=false] {boolean} Whether to activate local control (`true`) or disable it\n   * (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendLocalControl(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendLocalControl(e, t);\n    }), this;\n  }\n  /**\n   * Sets OMNI mode to **on** or **off** for the specified channel(s). MIDI\'s OMNI mode causes the\n   * instrument to respond to messages from all channels.\n   *\n   * It should be noted that support for OMNI mode is not as common as it used to be.\n   *\n   * @param [state] {boolean} Whether to activate OMNI mode (`true`) or not (`false`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {TypeError} Invalid channel mode message name.\n   * @throws {RangeError} Channel mode controller numbers must be between 120 and 127.\n   * @throws {RangeError} Value must be an integer between 0 and 127.\n   *\n   * @return {Output} Returns the `Output` object so methods can be chained.\n   *\n   * @since 3.0.0\n   */\n  sendOmniMode(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendOmniMode(e, t);\n    }), this;\n  }\n  /**\n   * Sets a non-registered parameter to the specified value. The NRPN is selected by passing a\n   * two-position array specifying the values of the two control bytes. The value is specified by\n   * passing a single integer (most cases) or an array of two integers.\n   *\n   * NRPNs are not standardized in any way. Each manufacturer is free to implement them any way\n   * they see fit. For example, according to the Roland GS specification, you can control the\n   * **vibrato rate** using NRPN (`1`, `8`). Therefore, to set the **vibrato rate** value to `123`\n   * you would use:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendNrpnValue([1, 8], 123);\n   * ```\n   *\n   * You probably want to should select a channel so the message is not sent to all channels. For\n   * instance, to send to channel `1` of the first output port, you would use:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendNrpnValue([1, 8], 123, 1);\n   * ```\n   *\n   * In some rarer cases, you need to send two values with your NRPN messages. In such cases, you\n   * would use a 2-position array. For example, for its **ClockBPM** parameter (`2`, `63`), Novation\n   * uses a 14-bit value that combines an MSB and an LSB (7-bit values). So, for example, if the\n   * value to send was `10`, you could use:\n   *\n   * ```js\n   * WebMidi.outputs[0].sendNrpnValue([2, 63], [0, 10], 1);\n   * ```\n   *\n   * For further implementation details, refer to the manufacturer\'s documentation.\n   *\n   * @param parameter {number[]} A two-position array specifying the two control bytes (`0x63`,\n   * `0x62`) that identify the non-registered parameter.\n   *\n   * @param [data=[]] {number|number[]} An integer or an array of integers with a length of 1 or 2\n   * specifying the desired data.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws {RangeError} The control value must be between 0 and 127.\n   * @throws {RangeError} The msb value must be between 0 and 127\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendNrpnValue(e, t, n = {}) {\n    return n.channels == null && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).forEach((r) => {\n      this.channels[r].sendNrpnValue(e, t, n);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  setNonRegisteredParameter(e, t = [], n = "all", r = {}) {\n    return l.validation && (console.warn(\n      "The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."\n    ), r.channels = n, r.channels === "all" && (r.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendNrpnValue(e, t, r);\n  }\n  /**\n   * Increments the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this method:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`\n   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`\n   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`\n   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`\n   *  * Modulation Range (0x00, 0x05): `"modulationrange"`\n   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`\n   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`\n   *  * Gain (0x3D, 0x02): `"gain"`\n   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`\n   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`\n   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`\n   *  * Roll Angle (0x3D, 0x08): `"rollangle"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter\'s name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendRpnIncrement(e, t = {}) {\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((n) => {\n      this.channels[n].sendRpnIncrement(e, t);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  incrementRegisteredParameter(e, t = "all", n = {}) {\n    return l.validation && (console.warn(\n      "The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."\n    ), n.channels = t, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendRpnIncrement(e, n);\n  }\n  /**\n   * Decrements the specified MIDI registered parameter by 1. Here is the full list of parameter\n   * names that can be used with this method:\n   *\n   *  * Pitchbend Range (0x00, 0x00): `"pitchbendrange"`\n   *  * Channel Fine Tuning (0x00, 0x01): `"channelfinetuning"`\n   *  * Channel Coarse Tuning (0x00, 0x02): `"channelcoarsetuning"`\n   *  * Tuning Program (0x00, 0x03): `"tuningprogram"`\n   *  * Tuning Bank (0x00, 0x04): `"tuningbank"`\n   *  * Modulation Range (0x00, 0x05): `"modulationrange"`\n   *  * Azimuth Angle (0x3D, 0x00): `"azimuthangle"`\n   *  * Elevation Angle (0x3D, 0x01): `"elevationangle"`\n   *  * Gain (0x3D, 0x02): `"gain"`\n   *  * Distance Ratio (0x3D, 0x03): `"distanceratio"`\n   *  * Maximum Distance (0x3D, 0x04): `"maximumdistance"`\n   *  * Maximum Distance Gain (0x3D, 0x05): `"maximumdistancegain"`\n   *  * Reference Distance Ratio (0x3D, 0x06): `"referencedistanceratio"`\n   *  * Pan Spread Angle (0x3D, 0x07): `"panspreadangle"`\n   *  * Roll Angle (0x3D, 0x08): `"rollangle"`\n   *\n   * @param parameter {String|number[]} A string identifying the parameter\'s name (see above) or a\n   * two-position array specifying the two control bytes (0x65, 0x64) that identify the registered\n   * parameter.\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @throws TypeError The specified parameter is not available.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendRpnDecrement(e, t = {}) {\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((n) => {\n      this.channels[n].sendRpnDecrement(e, t);\n    }), this;\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0\n   */\n  decrementRegisteredParameter(e, t = "all", n = {}) {\n    return l.validation && (console.warn(\n      "The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."\n    ), n.channels = t, n.channels === "all" && (n.channels = i.MIDI_CHANNEL_NUMBERS)), this.sendRpnDecrement(e, n);\n  }\n  /**\n   * Sends a **note off** message for the specified MIDI note number on the specified channel(s).\n   * The first parameter is the note to stop. It can be a single value or an array of the following\n   * valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *  - A [`Note`](Note) object\n   *\n   * The execution of the **note off** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`,\n   * `F-1`, `Db7`) or an array of the previous types. When using a note identifier, octave range\n   * must be between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest\n   * note is `G9` (MIDI note number `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note\n   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note\n   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `64`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendNoteOff(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendNoteOff(e, t);\n    }), this;\n  }\n  /**\n   * Sends a **note off** message for the specified MIDI note number on the specified channel(s).\n   * The first parameter is the note to stop. It can be a single value or an array of the following\n   * valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *  - A [`Note`](Note) object\n   *\n   * The execution of the **note off** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`, `F-1`,\n   * `Db7`) or an array of the previous types. When using a note identifier, octave range must be\n   * between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest note is\n   * `G9` (MIDI note number `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note\n   * (between `0` and `1`).  If the `rawRelease` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note\n   * (between `0` and `127`). If the `release` option is also defined, `rawRelease` will have\n   * priority. An invalid velocity value will silently trigger the default of `64`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  stopNote(e, t) {\n    return this.sendNoteOff(e, t);\n  }\n  /**\n   * Plays a note or an array of notes on one or more channels of this output. If you intend to play\n   * notes on a single channel, you should probably use\n   * [`OutputChannel.playNote()`](OutputChannel#playNote) instead.\n   *\n   * The first parameter is the note to play. It can be a single value or an array of the following\n   * valid values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *  - A [`Note`]{@link Note} object\n   *\n   * The `playNote()` method sends a **note on** MIDI message for all specified notes on all\n   * specified channels. If no channel is specified, it will send to all channels. If a `duration`\n   * is set in the `options` parameter or in the [`Note`]{@link Note} object\'s\n   * [`duration`]{@link Note#duration} property, it will also schedule a **note off** message to end\n   * the note after said duration. If no `duration` is set, the note will simply play until a\n   * matching **note off** message is sent with [`stopNote()`]{@link #stopNote}.\n   *\n   * The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * When using [`Note`]{@link Note} objects, the durations and velocities defined in the\n   * [`Note`]{@link Note} objects have precedence over the ones specified via the method\'s `options`\n   * parameter.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|string|Note|number[]|string[]|Note[]} The note(s) to play. The notes can be\n   * specified by using a MIDI note number (0-127), a note identifier (e.g. C3, G#4, F-1, Db7), a\n   * [`Note`]{@link Note} object or an array of the previous types. When using a note identifier,\n   * octave range must be between -1 and 9. The lowest note is C-1 (MIDI note number `0`) and the\n   * highest note is G9 (MIDI note number `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number} [options.duration=undefined] The number of milliseconds after which a\n   * **note off** message will be scheduled. If left undefined, only a **note on** message is sent.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`). If the `rawAttack` option is also defined, it will have priority. An invalid velocity\n   * value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawAttack=64] The attack velocity at which to play the note (between\n   * `0` and `127`). This has priority over the `attack` property. An invalid velocity value will\n   * silently trigger the default of 64.\n   *\n   * @param {number} [options.release=0.5] The velocity at which to release the note (between `0`\n   * and `1`). If the `rawRelease` option is also defined, it will have priority. An invalid\n   * velocity value will silently trigger the default of `0.5`. This is only used with the\n   * **note off** event triggered when `options.duration` is set.\n   *\n   * @param {number} [options.rawRelease=64] The velocity at which to release the note (between `0`\n   * and `127`). This has priority over the `release` property. An invalid velocity value will\n   * silently trigger the default of 64. This is only used with the **note off** event triggered\n   * when `options.duration` is set.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  playNote(e, t = {}, n = {}) {\n    if (l.validation && (t.rawVelocity && console.warn("The \'rawVelocity\' option is deprecated. Use \'rawAttack\' instead."), t.velocity && console.warn("The \'velocity\' option is deprecated. Use \'velocity\' instead."), Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].playNote(e, t);\n    }), this;\n  }\n  /**\n   * Sends a **note on** message for the specified MIDI note number on the specified channel(s). The\n   * first parameter is the number. It can be a single value or an array of the following valid\n   * values:\n   *\n   *  - A MIDI note number (integer between `0` and `127`)\n   *  - A note identifier (e.g. `"C3"`, `"G#4"`, `"F-1"`, `"Db7"`)\n   *  - A [`Note`](Note) object\n   *\n   *  The execution of the **note on** command can be delayed by using the `time` property of the\n   * `options` parameter.\n   *\n   * **Note**: As per the MIDI standard, a **note on** message with an attack velocity of `0` is\n   * functionally equivalent to a **note off** message.\n   *\n   * @param note {number|Note|string|number[]|Note[]|string[]} The note(s) to stop. The notes can be\n   * specified by using a MIDI note number (`0` - `127`), a note identifier (e.g. `C3`, `G#4`, `F-1`,\n   * `Db7`) or an array of the previous types. When using a note identifier, octave range must be\n   * between `-1` and `9`. The lowest note is `C-1` (MIDI note number `0`) and the highest note is\n   * `G9` (MIDI note number `127`).\n   *\n   * @param {Object} [options={}]\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * The MIDI channel number (between `1` and `16`) or an array of channel numbers to use. If no\n   * channel is specified, all channels will be used.\n   *\n   * @param {number} [options.attack=0.5] The velocity at which to play the note (between `0` and\n   * `1`).  If the `rawAttack` option is also defined, `rawAttack` will have priority. An invalid\n   * velocity value will silently trigger the default of `0.5`.\n   *\n   * @param {number} [options.rawAttack=64] The velocity at which to release the note (between `0`\n   * and `127`). If the `attack` option is also defined, `rawAttack` will have priority. An invalid\n   * velocity value will silently trigger the default of `64`.\n   *\n   * @param {number|string} [options.time=(now)] If `time` is a string prefixed with `"+"` and\n   * followed by a number, the message will be delayed by that many milliseconds. If the value is a\n   * positive number\n   * ([`DOMHighResTimeStamp`]{@link https://developer.mozilla.org/docs/Web/API/DOMHighResTimeStamp}),\n   * the operation will be scheduled for that time. The current time can be retrieved with\n   * [`WebMidi.time`]{@link WebMidi#time}. If `options.time` is omitted, or in the past, the\n   * operation will be carried out as soon as possible.\n   *\n   * @returns {Output} Returns the `Output` object so methods can be chained.\n   */\n  sendNoteOn(e, t = {}, n = {}) {\n    if (l.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {\n      const r = t;\n      t = n, t.channels = r, t.channels === "all" && (t.channels = i.MIDI_CHANNEL_NUMBERS);\n    }\n    return t.channels == null && (t.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(t.channels).forEach((r) => {\n      this.channels[r].sendNoteOn(e, t);\n    }), this;\n  }\n  /**\n   * Name of the MIDI output.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get name() {\n    return this._midiOutput.name;\n  }\n  /**\n   * ID string of the MIDI output. The ID is host-specific. Do not expect the same ID on different\n   * platforms. For example, Google Chrome and the Jazz-Plugin report completely different IDs for\n   * the same port.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get id() {\n    return this._midiOutput.id;\n  }\n  /**\n   * Output port\'s connection state: `pending`, `open` or `closed`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get connection() {\n    return this._midiOutput.connection;\n  }\n  /**\n   * Name of the manufacturer of the device that makes this output port available.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get manufacturer() {\n    return this._midiOutput.manufacturer;\n  }\n  /**\n   * State of the output port: `connected` or `disconnected`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get state() {\n    return this._midiOutput.state;\n  }\n  /**\n   * Type of the output port (it will always be: `output`).\n   *\n   * @type {string}\n   * @readonly\n   */\n  get type() {\n    return this._midiOutput.type;\n  }\n  /**\n   * An integer to offset the octave of outgoing notes. By default, middle C (MIDI note number 60)\n   * is placed on the 4th octave (C4).\n   *\n   * Note that this value is combined with the global offset value defined in\n   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) (if any).\n   *\n   * @type {number}\n   *\n   * @since 3.0\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(e) {\n    if (this.validation && (e = parseInt(e), isNaN(e)))\n      throw new TypeError("The \'octaveOffset\' property must be an integer.");\n    this._octaveOffset = e;\n  }\n}\n/**\n * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you\n * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object\n * to all the outputs listed in its [`destinations`](#destinations) property.\n *\n * If specific channels or message types have been defined in the [`channels`](#channels) or\n * [`types`](#types) properties, only messages matching the channels/types will be forwarded.\n *\n * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as\n * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.\n *\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass B {\n  /**\n   * Creates a `Forwarder` object.\n   *\n   * @param {Output|Output[]} [destinations=\\[\\]] An [`Output`](Output) object, or an array of such\n   * objects, to forward the message to.\n   *\n   * @param {object} [options={}]\n   * @param {string|string[]} [options.types=(all messages)] A MIDI message type or an array of such\n   * types (`"noteon"`, `"controlchange"`, etc.), that the specified message must match in order to\n   * be forwarded. If this option is not specified, all types of messages will be forwarded. Valid\n   * messages are the ones found in either\n   * [`SYSTEM_MESSAGES`](Enumerations#SYSTEM_MESSAGES)\n   * or [`CHANNEL_MESSAGES`](Enumerations#CHANNEL_MESSAGES).\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * A MIDI channel number or an array of channel numbers that the message must match in order to be\n   * forwarded. By default all MIDI channels are included (`1` to `16`).\n   */\n  constructor(e = [], t = {}) {\n    this.destinations = [], this.types = [\n      ...Object.keys(i.SYSTEM_MESSAGES),\n      ...Object.keys(i.CHANNEL_MESSAGES)\n    ], this.channels = i.MIDI_CHANNEL_NUMBERS, this.suspended = !1, Array.isArray(e) || (e = [e]), t.types && !Array.isArray(t.types) && (t.types = [t.types]), t.channels && !Array.isArray(t.channels) && (t.channels = [t.channels]), l.validation && (e.forEach((n) => {\n      if (!(n instanceof I))\n        throw new TypeError("Destinations must be of type \'Output\'.");\n    }), t.types !== void 0 && t.types.forEach((n) => {\n      if (!i.SYSTEM_MESSAGES.hasOwnProperty(n) && !i.CHANNEL_MESSAGES.hasOwnProperty(n))\n        throw new TypeError("Type must be a valid message type.");\n    }), t.channels !== void 0 && t.channels.forEach((n) => {\n      if (!i.MIDI_CHANNEL_NUMBERS.includes(n))\n        throw new TypeError("MIDI channel must be between 1 and 16.");\n    })), this.destinations = e, t.types && (this.types = t.types), t.channels && (this.channels = t.channels);\n  }\n  /**\n   * Sends the specified message to the forwarder\'s destination(s) if it matches the specified\n   * type(s) and channel(s).\n   *\n   * @param {Message} message The [`Message`](Message) object to forward.\n   */\n  forward(e) {\n    this.suspended || this.types.includes(e.type) && (e.channel && !this.channels.includes(e.channel) || this.destinations.forEach((t) => {\n      l.validation && !(t instanceof I) || t.send(e);\n    }));\n  }\n}\n/**\n * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input\n * device. This object is derived from the host\'s MIDI subsystem and should not be instantiated\n * directly.\n *\n * All 16 `InputChannel` objects can be found inside the input\'s [`channels`](Input#channels)\n * property.\n *\n * @fires InputChannel#midimessage\n * @fires InputChannel#unknownmessage\n *\n * @fires InputChannel#noteoff\n * @fires InputChannel#noteon\n * @fires InputChannel#keyaftertouch\n * @fires InputChannel#programchange\n * @fires InputChannel#channelaftertouch\n * @fires InputChannel#pitchbend\n *\n * @fires InputChannel#allnotesoff\n * @fires InputChannel#allsoundoff\n * @fires InputChannel#localcontrol\n * @fires InputChannel#monomode\n * @fires InputChannel#omnimode\n * @fires InputChannel#resetallcontrollers\n *\n * @fires InputChannel#event:nrpn\n * @fires InputChannel#event:nrpn-dataentrycoarse\n * @fires InputChannel#event:nrpn-dataentryfine\n * @fires InputChannel#event:nrpn-dataincrement\n * @fires InputChannel#event:nrpn-datadecrement\n * @fires InputChannel#event:rpn\n * @fires InputChannel#event:rpn-dataentrycoarse\n * @fires InputChannel#event:rpn-dataentryfine\n * @fires InputChannel#event:rpn-dataincrement\n * @fires InputChannel#event:rpn-datadecrement\n *\n * @fires InputChannel#controlchange\n * @fires InputChannel#event:controlchange-controllerxxx\n * @fires InputChannel#event:controlchange-bankselectcoarse\n * @fires InputChannel#event:controlchange-modulationwheelcoarse\n * @fires InputChannel#event:controlchange-breathcontrollercoarse\n * @fires InputChannel#event:controlchange-footcontrollercoarse\n * @fires InputChannel#event:controlchange-portamentotimecoarse\n * @fires InputChannel#event:controlchange-dataentrycoarse\n * @fires InputChannel#event:controlchange-volumecoarse\n * @fires InputChannel#event:controlchange-balancecoarse\n * @fires InputChannel#event:controlchange-pancoarse\n * @fires InputChannel#event:controlchange-expressioncoarse\n * @fires InputChannel#event:controlchange-effectcontrol1coarse\n * @fires InputChannel#event:controlchange-effectcontrol2coarse\n * @fires InputChannel#event:controlchange-generalpurposecontroller1\n * @fires InputChannel#event:controlchange-generalpurposecontroller2\n * @fires InputChannel#event:controlchange-generalpurposecontroller3\n * @fires InputChannel#event:controlchange-generalpurposecontroller4\n * @fires InputChannel#event:controlchange-bankselectfine\n * @fires InputChannel#event:controlchange-modulationwheelfine\n * @fires InputChannel#event:controlchange-breathcontrollerfine\n * @fires InputChannel#event:controlchange-footcontrollerfine\n * @fires InputChannel#event:controlchange-portamentotimefine\n * @fires InputChannel#event:controlchange-dataentryfine\n * @fires InputChannel#event:controlchange-channelvolumefine\n * @fires InputChannel#event:controlchange-balancefine\n * @fires InputChannel#event:controlchange-panfine\n * @fires InputChannel#event:controlchange-expressionfine\n * @fires InputChannel#event:controlchange-effectcontrol1fine\n * @fires InputChannel#event:controlchange-effectcontrol2fine\n * @fires InputChannel#event:controlchange-damperpedal\n * @fires InputChannel#event:controlchange-portamento\n * @fires InputChannel#event:controlchange-sostenuto\n * @fires InputChannel#event:controlchange-softpedal\n * @fires InputChannel#event:controlchange-legatopedal\n * @fires InputChannel#event:controlchange-hold2\n * @fires InputChannel#event:controlchange-soundvariation\n * @fires InputChannel#event:controlchange-resonance\n * @fires InputChannel#event:controlchange-releasetime\n * @fires InputChannel#event:controlchange-attacktime\n * @fires InputChannel#event:controlchange-brightness\n * @fires InputChannel#event:controlchange-decaytime\n * @fires InputChannel#event:controlchange-vibratorate\n * @fires InputChannel#event:controlchange-vibratodepth\n * @fires InputChannel#event:controlchange-vibratodelay\n * @fires InputChannel#event:controlchange-generalpurposecontroller5\n * @fires InputChannel#event:controlchange-generalpurposecontroller6\n * @fires InputChannel#event:controlchange-generalpurposecontroller7\n * @fires InputChannel#event:controlchange-generalpurposecontroller8\n * @fires InputChannel#event:controlchange-portamentocontrol\n * @fires InputChannel#event:controlchange-highresolutionvelocityprefix\n * @fires InputChannel#event:controlchange-effect1depth\n * @fires InputChannel#event:controlchange-effect2depth\n * @fires InputChannel#event:controlchange-effect3depth\n * @fires InputChannel#event:controlchange-effect4depth\n * @fires InputChannel#event:controlchange-effect5depth\n * @fires InputChannel#event:controlchange-dataincrement\n * @fires InputChannel#event:controlchange-datadecrement\n * @fires InputChannel#event:controlchange-nonregisteredparameterfine\n * @fires InputChannel#event:controlchange-nonregisteredparametercoarse\n * @fires InputChannel#event:controlchange-registeredparameterfine\n * @fires InputChannel#event:controlchange-registeredparametercoarse\n * @fires InputChannel#event:controlchange-allsoundoff\n * @fires InputChannel#event:controlchange-resetallcontrollers\n * @fires InputChannel#event:controlchange-localcontrol\n * @fires InputChannel#event:controlchange-allnotesoff\n * @fires InputChannel#event:controlchange-omnimodeoff\n * @fires InputChannel#event:controlchange-omnimodeon\n * @fires InputChannel#event:controlchange-monomodeon\n * @fires InputChannel#event:controlchange-polymodeon\n * @fires InputChannel#event:\n *\n * @extends EventEmitter\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass X extends E {\n  /**\n   * Creates an `InputChannel` object.\n   *\n   * @param {Input} input The [`Input`](Input) object this channel belongs to.\n   * @param {number} number The channel\'s MIDI number (1-16).\n   */\n  constructor(e, t) {\n    super(), this._input = e, this._number = t, this._octaveOffset = 0, this._nrpnBuffer = [], this._rpnBuffer = [], this.parameterNumberEventsEnabled = !0, this.notesState = new Array(128).fill(!1);\n  }\n  /**\n   * Destroys the `InputChannel` by removing all listeners and severing the link with the MIDI\n   * subsystem\'s input.\n   */\n  destroy() {\n    this._input = null, this._number = null, this._octaveOffset = 0, this._nrpnBuffer = [], this.notesState = new Array(128).fill(!1), this.parameterNumberEventsEnabled = !1, this.removeListener();\n  }\n  /**\n   * @param e MIDIMessageEvent\n   * @private\n   */\n  _processMidiMessageEvent(e) {\n    const t = Object.assign({}, e);\n    t.port = this.input, t.target = this, t.type = "midimessage", this.emit(t.type, t), this._parseEventForStandardMessages(t);\n  }\n  /**\n   * Parses incoming channel events and emit standard MIDI message events (noteon, noteoff, etc.)\n   * @param e Event\n   * @private\n   */\n  _parseEventForStandardMessages(e) {\n    const t = Object.assign({}, e);\n    t.type = t.message.type || "unknownmessage";\n    const n = e.message.dataBytes[0], r = e.message.dataBytes[1];\n    if (t.type === "noteoff" || t.type === "noteon" && r === 0)\n      this.notesState[n] = !1, t.type = "noteoff", t.note = new b(\n        o.offsetNumber(\n          n,\n          this.octaveOffset + this.input.octaveOffset + l.octaveOffset\n        ),\n        {\n          rawAttack: 0,\n          rawRelease: r\n        }\n      ), t.value = o.from7bitToFloat(r), t.rawValue = r, t.velocity = t.note.release, t.rawVelocity = t.note.rawRelease;\n    else if (t.type === "noteon")\n      this.notesState[n] = !0, t.note = new b(\n        o.offsetNumber(\n          n,\n          this.octaveOffset + this.input.octaveOffset + l.octaveOffset\n        ),\n        { rawAttack: r }\n      ), t.value = o.from7bitToFloat(r), t.rawValue = r, t.velocity = t.note.attack, t.rawVelocity = t.note.rawAttack;\n    else if (t.type === "keyaftertouch")\n      t.note = new b(\n        o.offsetNumber(\n          n,\n          this.octaveOffset + this.input.octaveOffset + l.octaveOffset\n        )\n      ), t.value = o.from7bitToFloat(r), t.rawValue = r, t.identifier = t.note.identifier, t.key = t.note.number, t.rawKey = n;\n    else if (t.type === "controlchange") {\n      t.controller = {\n        number: n,\n        name: i.CONTROL_CHANGE_MESSAGES[n].name,\n        description: i.CONTROL_CHANGE_MESSAGES[n].description,\n        position: i.CONTROL_CHANGE_MESSAGES[n].position\n      }, t.subtype = t.controller.name || "controller" + n, t.value = o.from7bitToFloat(r), t.rawValue = r;\n      const s = Object.assign({}, t);\n      s.type = `${t.type}-controller${n}`, delete s.subtype, this.emit(s.type, s);\n      const d = Object.assign({}, t);\n      d.type = `${t.type}-` + i.CONTROL_CHANGE_MESSAGES[n].name, delete d.subtype, d.type.indexOf("controller") !== 0 && this.emit(d.type, d), t.message.dataBytes[0] >= 120 && this._parseChannelModeMessage(t), this.parameterNumberEventsEnabled && this._isRpnOrNrpnController(t.message.dataBytes[0]) && this._parseEventForParameterNumber(t);\n    } else t.type === "programchange" ? (t.value = n, t.rawValue = t.value) : t.type === "channelaftertouch" ? (t.value = o.from7bitToFloat(n), t.rawValue = n) : t.type === "pitchbend" ? (t.value = ((r << 7) + n - 8192) / 8192, t.rawValue = (r << 7) + n) : t.type = "unknownmessage";\n    this.emit(t.type, t);\n  }\n  /**\n   * @param e {Object}\n   * @private\n   */\n  _parseChannelModeMessage(e) {\n    const t = Object.assign({}, e);\n    t.type = t.controller.name, t.type === "localcontrol" && (t.value = t.message.data[2] === 127, t.rawValue = t.message.data[2]), t.type === "omnimodeon" ? (t.type = "omnimode", t.value = !0, t.rawValue = t.message.data[2]) : t.type === "omnimodeoff" && (t.type = "omnimode", t.value = !1, t.rawValue = t.message.data[2]), t.type === "monomodeon" ? (t.type = "monomode", t.value = !0, t.rawValue = t.message.data[2]) : t.type === "polymodeon" && (t.type = "monomode", t.value = !1, t.rawValue = t.message.data[2]), this.emit(t.type, t);\n  }\n  /**\n   * Parses inbound events to identify RPN/NRPN sequences.\n   * @param e Event\n   * @private\n   */\n  _parseEventForParameterNumber(e) {\n    const t = e.message.dataBytes[0], n = e.message.dataBytes[1];\n    t === 99 || t === 101 ? (this._nrpnBuffer = [], this._rpnBuffer = [], t === 99 ? this._nrpnBuffer = [e.message] : n !== 127 && (this._rpnBuffer = [e.message])) : t === 98 || t === 100 ? t === 98 ? (this._rpnBuffer = [], this._nrpnBuffer.length === 1 ? this._nrpnBuffer.push(e.message) : this._nrpnBuffer = []) : (this._nrpnBuffer = [], this._rpnBuffer.length === 1 && n !== 127 ? this._rpnBuffer.push(e.message) : this._rpnBuffer = []) : (t === 6 || t === 38 || t === 96 || t === 97) && (this._rpnBuffer.length === 2 ? this._dispatchParameterNumberEvent(\n      "rpn",\n      this._rpnBuffer[0].dataBytes[1],\n      this._rpnBuffer[1].dataBytes[1],\n      e\n    ) : this._nrpnBuffer.length === 2 ? this._dispatchParameterNumberEvent(\n      "nrpn",\n      this._nrpnBuffer[0].dataBytes[1],\n      this._nrpnBuffer[1].dataBytes[1],\n      e\n    ) : (this._nrpnBuffer = [], this._rpnBuffer = []));\n  }\n  /**\n   * Indicates whether the specified controller can be part of an RPN or NRPN sequence\n   * @param controller\n   * @returns {boolean}\n   * @private\n   */\n  _isRpnOrNrpnController(e) {\n    return e === 6 || e === 38 || e === 96 || e === 97 || e === 98 || e === 99 || e === 100 || e === 101;\n  }\n  /**\n   * @private\n   */\n  _dispatchParameterNumberEvent(e, t, n, r) {\n    e = e === "nrpn" ? "nrpn" : "rpn";\n    const s = {\n      target: r.target,\n      timestamp: r.timestamp,\n      message: r.message,\n      parameterMsb: t,\n      parameterLsb: n,\n      value: o.from7bitToFloat(r.message.dataBytes[1]),\n      rawValue: r.message.dataBytes[1]\n    };\n    e === "rpn" ? s.parameter = Object.keys(i.REGISTERED_PARAMETERS).find((_) => i.REGISTERED_PARAMETERS[_][0] === t && i.REGISTERED_PARAMETERS[_][1] === n) : s.parameter = (t << 7) + n;\n    const d = i.CONTROL_CHANGE_MESSAGES[r.message.dataBytes[0]].name;\n    s.type = `${e}-${d}`, this.emit(s.type, s);\n    const h = Object.assign({}, s);\n    h.type === "nrpn-dataincrement" ? h.type = "nrpn-databuttonincrement" : h.type === "nrpn-datadecrement" ? h.type = "nrpn-databuttondecrement" : h.type === "rpn-dataincrement" ? h.type = "rpn-databuttonincrement" : h.type === "rpn-datadecrement" && (h.type = "rpn-databuttondecrement"), this.emit(h.type, h), s.type = e, s.subtype = d, this.emit(s.type, s);\n  }\n  /**\n   * @deprecated since version 3.\n   * @private\n   */\n  getChannelModeByNumber(e) {\n    return l.validation && (console.warn(\n      "The \'getChannelModeByNumber()\' method has been moved to the \'Utilities\' class."\n    ), e = Math.floor(e)), o.getChannelModeByNumber(e);\n  }\n  /**\n   * @deprecated since version 3.\n   * @private\n   */\n  getCcNameByNumber(e) {\n    if (l.validation && (console.warn(\n      "The \'getCcNameByNumber()\' method has been moved to the \'Utilities\' class."\n    ), e = parseInt(e), !(e >= 0 && e <= 127)))\n      throw new RangeError("Invalid control change number.");\n    return o.getCcNameByNumber(e);\n  }\n  /**\n   * Returns the playing status of the specified note (`true` if the note is currently playing,\n   * `false` if it is not). The `note` parameter can be an unsigned integer (0-127), a note\n   * identifier (`"C4"`, `"G#5"`, etc.) or a [`Note`]{@link Note} object.\n   *\n   * IF the note is specified using an integer (0-127), no octave offset will be applied.\n   *\n   * @param {number|string|Note} note The note to get the state for. The\n   * [`octaveOffset`](#octaveOffset) (channel, input and global) will be factored in for note\n   * identifiers and [`Note`]{@link Note} objects.\n   * @returns {boolean}\n   * @since version 3.0.0\n   */\n  getNoteState(e) {\n    e instanceof b && (e = e.identifier);\n    const t = o.guessNoteNumber(\n      e,\n      l.octaveOffset + this.input.octaveOffset + this.octaveOffset\n    );\n    return this.notesState[t];\n  }\n  /**\n   * An integer to offset the reported octave of incoming note-specific messages (`noteon`,\n   * `noteoff` and `keyaftertouch`). By default, middle C (MIDI note number 60) is placed on the 4th\n   * octave (C4).\n   *\n   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If\n   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.\n   *\n   * Note that this value is combined with the global offset value defined by\n   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) object and with the value defined on the parent\n   * input object with [`Input.octaveOffset`](Input#octaveOffset).\n   *\n   * @type {number}\n   *\n   * @since 3.0\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(e) {\n    if (this.validation && (e = parseInt(e), isNaN(e)))\n      throw new TypeError("The \'octaveOffset\' property must be an integer.");\n    this._octaveOffset = e;\n  }\n  /**\n   * The [`Input`](Input) this channel belongs to.\n   * @type {Input}\n   * @since 3.0\n   */\n  get input() {\n    return this._input;\n  }\n  /**\n   * This channel\'s MIDI number (1-16).\n   * @type {number}\n   * @since 3.0\n   */\n  get number() {\n    return this._number;\n  }\n  /**\n   * Whether RPN/NRPN events are parsed and dispatched.\n   * @type {boolean}\n   * @since 3.0\n   * @deprecated Use parameterNumberEventsEnabled instead.\n   * @private\n   */\n  get nrpnEventsEnabled() {\n    return this.parameterNumberEventsEnabled;\n  }\n  set nrpnEventsEnabled(e) {\n    this.validation && (e = !!e), this.parameterNumberEventsEnabled = e;\n  }\n}\n/**\n * The `Message` class represents a single MIDI message. It has several properties that make it\n * easy to make sense of the binary data it contains.\n *\n * @license Apache-2.0\n * @since 3.0.0\n */\nclass U {\n  /**\n   * Creates a new `Message` object from raw MIDI data.\n   *\n   * @param {Uint8Array} data The raw data of the MIDI message as a\n   * [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)\n   * of integers between `0` and `255`.\n   */\n  constructor(e) {\n    this.rawData = e, this.data = Array.from(this.rawData), this.statusByte = this.rawData[0], this.rawDataBytes = this.rawData.slice(1), this.dataBytes = this.data.slice(1), this.isChannelMessage = !1, this.isSystemMessage = !1, this.command = void 0, this.channel = void 0, this.manufacturerId = void 0, this.type = void 0, this.statusByte < 240 ? (this.isChannelMessage = !0, this.command = this.statusByte >> 4, this.channel = (this.statusByte & 15) + 1) : (this.isSystemMessage = !0, this.command = this.statusByte), this.isChannelMessage ? this.type = o.getPropertyByValue(i.CHANNEL_MESSAGES, this.command) : this.isSystemMessage && (this.type = o.getPropertyByValue(i.SYSTEM_MESSAGES, this.command)), this.statusByte === i.SYSTEM_MESSAGES.sysex && (this.dataBytes[0] === 0 ? (this.manufacturerId = this.dataBytes.slice(0, 3), this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1)) : (this.manufacturerId = [this.dataBytes[0]], this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1), this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1)));\n  }\n}\n/**\n * The `Input` class represents a single MIDI input port. This object is automatically instantiated\n * by the library according to the host\'s MIDI subsystem and does not need to be directly\n * instantiated. Instead, you can access all `Input` objects by referring to the\n * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as\n * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and\n * [`WebMidi.getInputById()`](WebMidi#getInputById).\n *\n * Note that a single MIDI device may expose several inputs and/or outputs.\n *\n * **Important**: the `Input` class does not directly fire channel-specific MIDI messages\n * (such as [`noteon`](InputChannel#event:noteon) or\n * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)\n * object does that. However, you can still use the\n * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple\n * [`InputChannel`](InputChannel) objects at once.\n *\n * @fires Input#opened\n * @fires Input#disconnected\n * @fires Input#closed\n * @fires Input#midimessage\n *\n * @fires Input#sysex\n * @fires Input#timecode\n * @fires Input#songposition\n * @fires Input#songselect\n * @fires Input#tunerequest\n * @fires Input#clock\n * @fires Input#start\n * @fires Input#continue\n * @fires Input#stop\n * @fires Input#activesensing\n * @fires Input#reset\n *\n * @fires Input#unknownmidimessage\n *\n * @extends EventEmitter\n * @license Apache-2.0\n */\nclass Z extends E {\n  /**\n   * Creates an `Input` object.\n   *\n   * @param {MIDIInput} midiInput [`MIDIInput`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIInput)\n   * object as provided by the MIDI subsystem (Web MIDI API).\n   */\n  constructor(e) {\n    super(), this._midiInput = e, this._octaveOffset = 0, this.channels = [];\n    for (let t = 1; t <= 16; t++) this.channels[t] = new X(this, t);\n    this._forwarders = [], this._midiInput.onstatechange = this._onStateChange.bind(this), this._midiInput.onmidimessage = this._onMidiMessage.bind(this);\n  }\n  /**\n   * Destroys the `Input` by removing all listeners, emptying the [`channels`](#channels) array and\n   * unlinking the MIDI subsystem. This is mostly for internal use.\n   *\n   * @returns {Promise<void>}\n   */\n  async destroy() {\n    this.removeListener(), this.channels.forEach((e) => e.destroy()), this.channels = [], this._forwarders = [], this._midiInput && (this._midiInput.onstatechange = null, this._midiInput.onmidimessage = null), await this.close(), this._midiInput = null;\n  }\n  /**\n   * Executed when a `"statechange"` event occurs.\n   *\n   * @param e\n   * @private\n   */\n  _onStateChange(e) {\n    let t = {\n      timestamp: l.time,\n      target: this,\n      port: this\n      // for consistency\n    };\n    e.port.connection === "open" ? (t.type = "opened", this.emit("opened", t)) : e.port.connection === "closed" && e.port.state === "connected" ? (t.type = "closed", this.emit("closed", t)) : e.port.connection === "closed" && e.port.state === "disconnected" ? (t.type = "disconnected", t.port = {\n      connection: e.port.connection,\n      id: e.port.id,\n      manufacturer: e.port.manufacturer,\n      name: e.port.name,\n      state: e.port.state,\n      type: e.port.type\n    }, this.emit("disconnected", t)) : e.port.connection === "pending" && e.port.state === "disconnected" || console.warn("This statechange event was not caught: ", e.port.connection, e.port.state);\n  }\n  /**\n   * Executed when a `"midimessage"` event is received\n   * @param e\n   * @private\n   */\n  _onMidiMessage(e) {\n    const t = new U(e.data), n = {\n      port: this,\n      target: this,\n      message: t,\n      timestamp: e.timeStamp,\n      type: "midimessage",\n      data: t.data,\n      // @deprecated (will be removed in v4)\n      rawData: t.data,\n      // @deprecated (will be removed in v4)\n      statusByte: t.data[0],\n      // @deprecated (will be removed in v4)\n      dataBytes: t.dataBytes\n      // @deprecated (will be removed in v4)\n    };\n    this.emit("midimessage", n), t.isSystemMessage ? this._parseEvent(n) : t.isChannelMessage && this.channels[t.channel]._processMidiMessageEvent(n), this._forwarders.forEach((r) => r.forward(t));\n  }\n  /**\n   * @private\n   */\n  _parseEvent(e) {\n    const t = Object.assign({}, e);\n    t.type = t.message.type || "unknownmidimessage", t.type === "songselect" && (t.song = e.data[1] + 1, t.value = e.data[1], t.rawValue = t.value), this.emit(t.type, t);\n  }\n  /**\n   * Opens the input for usage. This is usually unnecessary as the port is opened automatically when\n   * WebMidi is enabled.\n   *\n   * @returns {Promise<Input>} The promise is fulfilled with the `Input` object.\n   */\n  async open() {\n    try {\n      await this._midiInput.open();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    return Promise.resolve(this);\n  }\n  /**\n   * Closes the input. When an input is closed, it cannot be used to listen to MIDI messages until\n   * the input is opened again by calling [`Input.open()`](Input#open).\n   *\n   * **Note**: if what you want to do is stop events from being dispatched, you should use\n   * [`eventsSuspended`](#eventsSuspended) instead.\n   *\n   * @returns {Promise<Input>} The promise is fulfilled with the `Input` object\n   */\n  async close() {\n    if (!this._midiInput) return Promise.resolve(this);\n    try {\n      await this._midiInput.close();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n    return Promise.resolve(this);\n  }\n  /**\n   * @private\n   * @deprecated since v3.0.0 (moved to \'Utilities\' class)\n   */\n  getChannelModeByNumber() {\n    l.validation && console.warn(\n      "The \'getChannelModeByNumber()\' method has been moved to the \'Utilities\' class."\n    );\n  }\n  /**\n   * Adds an event listener that will trigger a function callback when the specified event is\n   * dispatched. The event usually is **input-wide** but can also be **channel-specific**.\n   *\n   * Input-wide events do not target a specific MIDI channel so it makes sense to listen for them\n   * at the `Input` level and not at the [`InputChannel`](InputChannel) level. Channel-specific\n   * events target a specific channel. Usually, in this case, you would add the listener to the\n   * [`InputChannel`](InputChannel) object. However, as a convenience, you can also listen to\n   * channel-specific events directly on an `Input`. This allows you to react to a channel-specific\n   * event no matter which channel it actually came through.\n   *\n   * When listening for an event, you simply need to specify the event name and the function to\n   * execute:\n   *\n   * ```javascript\n   * const listener = WebMidi.inputs[0].addListener("midimessage", e => {\n   *   console.log(e);\n   * });\n   * ```\n   *\n   * Calling the function with an input-wide event (such as\n   * [`"midimessage"`]{@link #event:midimessage}), will return the [`Listener`](Listener) object\n   * that was created.\n   *\n   * If you call the function with a channel-specific event (such as\n   * [`"noteon"`]{@link InputChannel#event:noteon}), it will return an array of all\n   * [`Listener`](Listener) objects that were created (one for each channel):\n   *\n   * ```javascript\n   * const listeners = WebMidi.inputs[0].addListener("noteon", someFunction);\n   * ```\n   *\n   * You can also specify which channels you want to add the listener to:\n   *\n   * ```javascript\n   * const listeners = WebMidi.inputs[0].addListener("noteon", someFunction, {channels: [1, 2, 3]});\n   * ```\n   *\n   * In this case, `listeners` is an array containing 3 [`Listener`](Listener) objects. The order of\n   * the listeners in the array follows the order the channels were specified in.\n   *\n   * Note that, when adding channel-specific listeners, it is the [`InputChannel`](InputChannel)\n   * instance that actually gets a listener added and not the `Input` instance. You can check that\n   * by calling [`InputChannel.hasListener()`](InputChannel#hasListener()).\n   *\n   * There are 8 families of events you can listen to:\n   *\n   * 1. **MIDI System Common** Events (input-wide)\n   *\n   *    * [`songposition`]{@link Input#event:songposition}\n   *    * [`songselect`]{@link Input#event:songselect}\n   *    * [`sysex`]{@link Input#event:sysex}\n   *    * [`timecode`]{@link Input#event:timecode}\n   *    * [`tunerequest`]{@link Input#event:tunerequest}\n   *\n   * 2. **MIDI System Real-Time** Events (input-wide)\n   *\n   *    * [`clock`]{@link Input#event:clock}\n   *    * [`start`]{@link Input#event:start}\n   *    * [`continue`]{@link Input#event:continue}\n   *    * [`stop`]{@link Input#event:stop}\n   *    * [`activesensing`]{@link Input#event:activesensing}\n   *    * [`reset`]{@link Input#event:reset}\n   *\n   * 3. **State Change** Events (input-wide)\n   *\n   *    * [`opened`]{@link Input#event:opened}\n   *    * [`closed`]{@link Input#event:closed}\n   *    * [`disconnected`]{@link Input#event:disconnected}\n   *\n   * 4. **Catch-All** Events (input-wide)\n   *\n   *    * [`midimessage`]{@link Input#event:midimessage}\n   *    * [`unknownmidimessage`]{@link Input#event:unknownmidimessage}\n   *\n   * 5. **Channel Voice** Events (channel-specific)\n   *\n   *    * [`channelaftertouch`]{@link InputChannel#event:channelaftertouch}\n   *    * [`controlchange`]{@link InputChannel#event:controlchange}\n   *      * [`controlchange-controller0`]{@link InputChannel#event:controlchange-controller0}\n   *      * [`controlchange-controller1`]{@link InputChannel#event:controlchange-controller1}\n   *      * [`controlchange-controller2`]{@link InputChannel#event:controlchange-controller2}\n   *      * (...)\n   *      * [`controlchange-controller127`]{@link InputChannel#event:controlchange-controller127}\n   *    * [`keyaftertouch`]{@link InputChannel#event:keyaftertouch}\n   *    * [`noteoff`]{@link InputChannel#event:noteoff}\n   *    * [`noteon`]{@link InputChannel#event:noteon}\n   *    * [`pitchbend`]{@link InputChannel#event:pitchbend}\n   *    * [`programchange`]{@link InputChannel#event:programchange}\n   *\n   *    Note: you can listen for a specific control change message by using an event name like this:\n   *    `controlchange-controller23`, `controlchange-controller99`, `controlchange-controller122`,\n   *    etc.\n   *\n   * 6. **Channel Mode** Events (channel-specific)\n   *\n   *    * [`allnotesoff`]{@link InputChannel#event:allnotesoff}\n   *    * [`allsoundoff`]{@link InputChannel#event:allsoundoff}\n   *    * [`localcontrol`]{@link InputChannel#event:localcontrol}\n   *    * [`monomode`]{@link InputChannel#event:monomode}\n   *    * [`omnimode`]{@link InputChannel#event:omnimode}\n   *    * [`resetallcontrollers`]{@link InputChannel#event:resetallcontrollers}\n   *\n   * 7. **NRPN** Events (channel-specific)\n   *\n   *    * [`nrpn`]{@link InputChannel#event:nrpn}\n   *    * [`nrpn-dataentrycoarse`]{@link InputChannel#event:nrpn-dataentrycoarse}\n   *    * [`nrpn-dataentryfine`]{@link InputChannel#event:nrpn-dataentryfine}\n   *    * [`nrpn-dataincrement`]{@link InputChannel#event:nrpn-dataincrement}\n   *    * [`nrpn-datadecrement`]{@link InputChannel#event:nrpn-datadecrement}\n   *\n   * 8. **RPN** Events (channel-specific)\n   *\n   *    * [`rpn`]{@link InputChannel#event:rpn}\n   *    * [`rpn-dataentrycoarse`]{@link InputChannel#event:rpn-dataentrycoarse}\n   *    * [`rpn-dataentryfine`]{@link InputChannel#event:rpn-dataentryfine}\n   *    * [`rpn-dataincrement`]{@link InputChannel#event:rpn-dataincrement}\n   *    * [`rpn-datadecrement`]{@link InputChannel#event:rpn-datadecrement}\n   *\n   * @param event {string | EventEmitter.ANY_EVENT} The type of the event.\n   *\n   * @param listener {function} A callback function to execute when the specified event is detected.\n   * This function will receive an event parameter object. For details on this object\'s properties,\n   * check out the documentation for the various events (links above).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the [`arguments`](Listener#arguments) property of\n   * the [`Listener`](Listener) object and can be retrieved or modified as desired.\n   *\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * An integer between 1 and 16 or an array of such integers representing the MIDI channel(s) to\n   * listen on. If no channel is specified, all channels will be used. This parameter is ignored for\n   * input-wide events.\n   *\n   * @param {object} [options.context=this] The value of `this` in the callback function.\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   *\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array and thus be triggered before others.\n   *\n   * @param {number} [options.remaining=Infinity] The number of times after which the callback\n   * should automatically be removed.\n   *\n   * @returns {Listener|Listener[]} If the event is input-wide, a single [`Listener`](Listener)\n   * object is returned. If the event is channel-specific, an array of all the\n   * [`Listener`](Listener) objects is returned (one for each channel).\n   */\n  addListener(e, t, n = {}) {\n    if (l.validation && typeof n == "function") {\n      let r = t != null ? [].concat(t) : void 0;\n      t = n, n = { channels: r };\n    }\n    if (i.CHANNEL_EVENTS.includes(e)) {\n      n.channels === void 0 && (n.channels = i.MIDI_CHANNEL_NUMBERS);\n      let r = [];\n      return o.sanitizeChannels(n.channels).forEach((s) => {\n        r.push(this.channels[s].addListener(e, t, n));\n      }), r;\n    } else\n      return super.addListener(e, t, n);\n  }\n  /**\n   * Adds a one-time event listener that will trigger a function callback when the specified event\n   * happens. The event can be **channel-bound** or **input-wide**. Channel-bound events are\n   * dispatched by [`InputChannel`]{@link InputChannel} objects and are tied to a specific MIDI\n   * channel while input-wide events are dispatched by the `Input` object itself and are not tied\n   * to a specific channel.\n   *\n   * Calling the function with an input-wide event (such as\n   * [`"midimessage"`]{@link #event:midimessage}), will return the [`Listener`](Listener) object\n   * that was created.\n   *\n   * If you call the function with a channel-specific event (such as\n   * [`"noteon"`]{@link InputChannel#event:noteon}), it will return an array of all\n   * [`Listener`](Listener) objects that were created (one for each channel):\n   *\n   * ```javascript\n   * const listeners = WebMidi.inputs[0].addOneTimeListener("noteon", someFunction);\n   * ```\n   *\n   * You can also specify which channels you want to add the listener to:\n   *\n   * ```javascript\n   * const listeners = WebMidi.inputs[0].addOneTimeListener("noteon", someFunction, {channels: [1, 2, 3]});\n   * ```\n   *\n   * In this case, the `listeners` variable contains an array of 3 [`Listener`](Listener) objects.\n   *\n   * The code above will add a listener for the `"noteon"` event and call `someFunction` when the\n   * event is triggered on MIDI channels `1`, `2` or `3`.\n   *\n   * Note that, when adding events to channels, it is the [`InputChannel`](InputChannel) instance\n   * that actually gets a listener added and not the `Input` instance.\n   *\n   * Note: if you want to add a listener to a single MIDI channel you should probably do so directly\n   * on the [`InputChannel`](InputChannel) object itself.\n   *\n   * There are 8 families of events you can listen to:\n   *\n   * 1. **MIDI System Common** Events (input-wide)\n   *\n   *    * [`songposition`]{@link Input#event:songposition}\n   *    * [`songselect`]{@link Input#event:songselect}\n   *    * [`sysex`]{@link Input#event:sysex}\n   *    * [`timecode`]{@link Input#event:timecode}\n   *    * [`tunerequest`]{@link Input#event:tunerequest}\n   *\n   * 2. **MIDI System Real-Time** Events (input-wide)\n   *\n   *    * [`clock`]{@link Input#event:clock}\n   *    * [`start`]{@link Input#event:start}\n   *    * [`continue`]{@link Input#event:continue}\n   *    * [`stop`]{@link Input#event:stop}\n   *    * [`activesensing`]{@link Input#event:activesensing}\n   *    * [`reset`]{@link Input#event:reset}\n   *\n   * 3. **State Change** Events (input-wide)\n   *\n   *    * [`opened`]{@link Input#event:opened}\n   *    * [`closed`]{@link Input#event:closed}\n   *    * [`disconnected`]{@link Input#event:disconnected}\n   *\n   * 4. **Catch-All** Events (input-wide)\n   *\n   *    * [`midimessage`]{@link Input#event:midimessage}\n   *    * [`unknownmidimessage`]{@link Input#event:unknownmidimessage}\n   *\n   * 5. **Channel Voice** Events (channel-specific)\n   *\n   *    * [`channelaftertouch`]{@link InputChannel#event:channelaftertouch}\n   *    * [`controlchange`]{@link InputChannel#event:controlchange}\n   *      * [`controlchange-controller0`]{@link InputChannel#event:controlchange-controller0}\n   *      * [`controlchange-controller1`]{@link InputChannel#event:controlchange-controller1}\n   *      * [`controlchange-controller2`]{@link InputChannel#event:controlchange-controller2}\n   *      * (...)\n   *      * [`controlchange-controller127`]{@link InputChannel#event:controlchange-controller127}\n   *    * [`keyaftertouch`]{@link InputChannel#event:keyaftertouch}\n   *    * [`noteoff`]{@link InputChannel#event:noteoff}\n   *    * [`noteon`]{@link InputChannel#event:noteon}\n   *    * [`pitchbend`]{@link InputChannel#event:pitchbend}\n   *    * [`programchange`]{@link InputChannel#event:programchange}\n   *\n   *    Note: you can listen for a specific control change message by using an event name like this:\n   *    `controlchange-controller23`, `controlchange-controller99`, `controlchange-controller122`,\n   *    etc.\n   *\n   * 6. **Channel Mode** Events (channel-specific)\n   *\n   *    * [`allnotesoff`]{@link InputChannel#event:allnotesoff}\n   *    * [`allsoundoff`]{@link InputChannel#event:allsoundoff}\n   *    * [`localcontrol`]{@link InputChannel#event:localcontrol}\n   *    * [`monomode`]{@link InputChannel#event:monomode}\n   *    * [`omnimode`]{@link InputChannel#event:omnimode}\n   *    * [`resetallcontrollers`]{@link InputChannel#event:resetallcontrollers}\n   *\n   * 7. **NRPN** Events (channel-specific)\n   *\n   *    * [`nrpn`]{@link InputChannel#event:nrpn}\n   *    * [`nrpn-dataentrycoarse`]{@link InputChannel#event:nrpn-dataentrycoarse}\n   *    * [`nrpn-dataentryfine`]{@link InputChannel#event:nrpn-dataentryfine}\n   *    * [`nrpn-dataincrement`]{@link InputChannel#event:nrpn-dataincrement}\n   *    * [`nrpn-datadecrement`]{@link InputChannel#event:nrpn-datadecrement}\n   *\n   * 8. **RPN** Events (channel-specific)\n   *\n   *    * [`rpn`]{@link InputChannel#event:rpn}\n   *    * [`rpn-dataentrycoarse`]{@link InputChannel#event:rpn-dataentrycoarse}\n   *    * [`rpn-dataentryfine`]{@link InputChannel#event:rpn-dataentryfine}\n   *    * [`rpn-dataincrement`]{@link InputChannel#event:rpn-dataincrement}\n   *    * [`rpn-datadecrement`]{@link InputChannel#event:rpn-datadecrement}\n   *\n   * @param event {string} The type of the event.\n   *\n   * @param listener {function} A callback function to execute when the specified event is detected.\n   * This function will receive an event parameter object. For details on this object\'s properties,\n   * check out the documentation for the various events (links above).\n   *\n   * @param {object} [options={}]\n   *\n   * @param {array} [options.arguments] An array of arguments which will be passed separately to the\n   * callback function. This array is stored in the [`arguments`](Listener#arguments) property of\n   * the [`Listener`](Listener) object and can be retrieved or modified as desired.\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of\n   * such integers representing the MIDI channel(s) to listen on. This parameter is ignored for\n   * input-wide events.\n   *\n   * @param {object} [options.context=this] The value of `this` in the callback function.\n   *\n   * @param {number} [options.duration=Infinity] The number of milliseconds before the listener\n   * automatically expires.\n   *\n   * @param {boolean} [options.prepend=false] Whether the listener should be added at the beginning\n   * of the listeners array and thus be triggered before others.\n   *\n   * @returns {Listener[]} An array of all [`Listener`](Listener) objects that were created.\n   */\n  addOneTimeListener(e, t, n = {}) {\n    return n.remaining = 1, this.addListener(e, t, n);\n  }\n  /**\n   * This is an alias to the [Input.addListener()]{@link Input#addListener} method.\n   * @since 2.0.0\n   * @deprecated since v3.0\n   * @private\n   */\n  on(e, t, n, r) {\n    return this.addListener(e, t, n, r);\n  }\n  /**\n   * Checks if the specified event type is already defined to trigger the specified callback\n   * function. For channel-specific events, the function will return `true` only if all channels\n   * have the listener defined.\n   *\n   * @param event {string|Symbol} The type of the event.\n   *\n   * @param listener {function} The callback function to check for.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of such\n   * integers representing the MIDI channel(s) to check. This parameter is ignored for input-wide\n   * events.\n   *\n   * @returns {boolean} Boolean value indicating whether or not the `Input` or\n   * [`InputChannel`](InputChannel) already has this listener defined.\n   */\n  hasListener(e, t, n = {}) {\n    if (l.validation && typeof n == "function") {\n      let r = [].concat(t);\n      t = n, n = { channels: r };\n    }\n    return i.CHANNEL_EVENTS.includes(e) ? (n.channels === void 0 && (n.channels = i.MIDI_CHANNEL_NUMBERS), o.sanitizeChannels(n.channels).every((r) => this.channels[r].hasListener(e, t))) : super.hasListener(e, t);\n  }\n  /**\n   * Removes the specified event listener. If no listener is specified, all listeners matching the\n   * specified event will be removed. If the event is channel-specific, the listener will be removed\n   * from all [`InputChannel`]{@link InputChannel} objects belonging to that channel. If no event is\n   * specified, all listeners for the `Input` as well as all listeners for all\n   * [`InputChannel`]{@link InputChannel} objects belonging to the `Input` will be removed.\n   *\n   * By default, channel-specific listeners will be removed from all\n   * [`InputChannel`]{@link InputChannel} objects unless the `options.channel` narrows it down.\n   *\n   * @param [type] {string} The type of the event.\n   *\n   * @param [listener] {function} The callback function to check for.\n   *\n   * @param {object} [options={}]\n   *\n   * @param {number|number[]} [options.channels]  An integer between 1 and 16 or an array of\n   * such integers representing the MIDI channel(s) to match. This parameter is ignored for\n   * input-wide events.\n   *\n   * @param {*} [options.context] Only remove the listeners that have this exact context.\n   *\n   * @param {number} [options.remaining] Only remove the listener if it has exactly that many\n   * remaining times to be executed.\n   */\n  removeListener(e, t, n = {}) {\n    if (l.validation && typeof n == "function") {\n      let r = [].concat(t);\n      t = n, n = { channels: r };\n    }\n    if (n.channels === void 0 && (n.channels = i.MIDI_CHANNEL_NUMBERS), e == null)\n      return o.sanitizeChannels(n.channels).forEach((r) => {\n        this.channels[r] && this.channels[r].removeListener();\n      }), super.removeListener();\n    i.CHANNEL_EVENTS.includes(e) ? o.sanitizeChannels(n.channels).forEach((r) => {\n      this.channels[r].removeListener(e, t, n);\n    }) : super.removeListener(e, t, n);\n  }\n  /**\n   * Adds a forwarder that will forward all incoming MIDI messages matching the criteria to the\n   * specified [`Output`](Output) destination(s). This is akin to the hardware MIDI THRU port, with\n   * the added benefit of being able to filter which data is forwarded.\n   *\n   * @param {Output|Output[]} output An [`Output`](Output) object, or an array of such\n   * objects, to forward messages to.\n   * @param {object} [options={}]\n   * @param {string|string[]} [options.types=(all messages)] A message type, or an array of such\n   * types (`noteon`, `controlchange`, etc.), that the message type must match in order to be\n   * forwarded. If this option is not specified, all types of messages will be forwarded. Valid\n   * messages are the ones found in either\n   * [`SYSTEM_MESSAGES`](Enumerations#SYSTEM_MESSAGES) or\n   * [`CHANNEL_MESSAGES`](Enumerations#CHANNEL_MESSAGES).\n   * @param {number|number[]} [options.channels=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]]\n   * A MIDI channel number or an array of channel numbers that the message must match in order to be\n   * forwarded. By default all MIDI channels are included (`1` to `16`).\n   *\n   * @returns {Forwarder} The [`Forwarder`](Forwarder) object created to handle the forwarding. This\n   * is useful if you wish to manipulate or remove the [`Forwarder`](Forwarder) later on.\n   */\n  addForwarder(e, t = {}) {\n    let n;\n    return e instanceof B ? n = e : n = new B(e, t), this._forwarders.push(n), n;\n  }\n  /**\n   * Removes the specified [`Forwarder`](Forwarder) object from the input.\n   *\n   * @param {Forwarder} forwarder The [`Forwarder`](Forwarder) to remove (the\n   * [`Forwarder`](Forwarder) object is returned when calling `addForwarder()`.\n   */\n  removeForwarder(e) {\n    this._forwarders = this._forwarders.filter((t) => t !== e);\n  }\n  /**\n   * Checks whether the specified [`Forwarder`](Forwarder) object has already been attached to this\n   * input.\n   *\n   * @param {Forwarder} forwarder The [`Forwarder`](Forwarder) to check for (the\n   * [`Forwarder`](Forwarder) object is returned when calling [`addForwarder()`](#addForwarder).\n   * @returns {boolean}\n   */\n  hasForwarder(e) {\n    return this._forwarders.includes(e);\n  }\n  /**\n   * Name of the MIDI input.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get name() {\n    return this._midiInput.name;\n  }\n  /**\n   * ID string of the MIDI port. The ID is host-specific. Do not expect the same ID on different\n   * platforms. For example, Google Chrome and the Jazz-Plugin report completely different IDs for\n   * the same port.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get id() {\n    return this._midiInput.id;\n  }\n  /**\n   * Input port\'s connection state: `pending`, `open` or `closed`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get connection() {\n    return this._midiInput.connection;\n  }\n  /**\n   * Name of the manufacturer of the device that makes this input port available.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get manufacturer() {\n    return this._midiInput.manufacturer;\n  }\n  /**\n   * An integer to offset the reported octave of incoming notes. By default, middle C (MIDI note\n   * number 60) is placed on the 4th octave (C4).\n   *\n   * If, for example, `octaveOffset` is set to 2, MIDI note number 60 will be reported as C6. If\n   * `octaveOffset` is set to -1, MIDI note number 60 will be reported as C3.\n   *\n   * Note that this value is combined with the global offset value defined in the\n   * [`WebMidi.octaveOffset`](WebMidi#octaveOffset) property (if any).\n   *\n   * @type {number}\n   *\n   * @since 3.0\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(e) {\n    if (this.validation && (e = parseInt(e), isNaN(e)))\n      throw new TypeError("The \'octaveOffset\' property must be an integer.");\n    this._octaveOffset = e;\n  }\n  /**\n   * State of the input port: `connected` or `disconnected`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get state() {\n    return this._midiInput.state;\n  }\n  /**\n   * The port type. In the case of the `Input` object, this is always: `input`.\n   *\n   * @type {string}\n   * @readonly\n   */\n  get type() {\n    return this._midiInput.type;\n  }\n  /**\n   * @type {boolean}\n   * @private\n   * @deprecated since v3.0.0 (moved to \'InputChannel\' class)\n   */\n  get nrpnEventsEnabled() {\n    return l.validation && console.warn("The \'nrpnEventsEnabled\' property has been moved to the \'InputChannel\' class."), !1;\n  }\n}\n/**\n * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it\n * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.\n *\n * When using the WebMidi.js library, you should know that the `WebMidi` class has already been\n * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should\n * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6\n * module) version, you get an already-instantiated object when you import the module.\n *\n * @fires WebMidi#connected\n * @fires WebMidi#disabled\n * @fires WebMidi#disconnected\n * @fires WebMidi#enabled\n * @fires WebMidi#error\n * @fires WebMidi#midiaccessgranted\n * @fires WebMidi#portschanged\n *\n * @extends EventEmitter\n * @license Apache-2.0\n */\nlet oe = class extends E {\n  /**\n   * The WebMidi class is a singleton and you cannot instantiate it directly. It has already been\n   * instantiated for you.\n   */\n  constructor() {\n    super(), this.defaults = {\n      note: {\n        attack: o.from7bitToFloat(64),\n        release: o.from7bitToFloat(64),\n        duration: 1 / 0\n      }\n    }, this.interface = null, this.validation = !0, this._inputs = [], this._disconnectedInputs = [], this._outputs = [], this._disconnectedOutputs = [], this._stateChangeQueue = [], this._octaveOffset = 0;\n  }\n  /**\n   * Checks if the Web MIDI API is available in the current environment and then tries to connect to\n   * the host\'s MIDI subsystem. This is an asynchronous operation and it causes a security prompt to\n   * be displayed to the user.\n   *\n   * To enable the use of MIDI system exclusive messages, the `sysex` option should be set to\n   * `true`. However, under some environments (e.g. Jazz-Plugin), the `sysex` option is ignored\n   * and system exclusive messages are always enabled. You can check the\n   * [`sysexEnabled`](#sysexEnabled) property to confirm.\n   *\n   * To enable access to software synthesizers available on the host, you would set the `software`\n   * option to `true`. However, this option is only there to future-proof the library as support for\n   * software synths has not yet been implemented in any browser (as of September 2021).\n   *\n   * By the way, if you call the [`enable()`](#enable) method while WebMidi.js is already enabled,\n   * the callback function will be executed (if any), the promise will resolve but the events\n   * ([`"midiaccessgranted"`](#event:midiaccessgranted), [`"connected"`](#event:connected) and\n   * [`"enabled"`](#event:enabled)) will not be fired.\n   *\n   * There are 3 ways to execute code after `WebMidi` has been enabled:\n   *\n   * - Pass a callback function in the `options`\n   * - Listen to the [`"enabled"`](#event:enabled) event\n   * - Wait for the promise to resolve\n   *\n   * In order, this is what happens towards the end of the enabling process:\n   *\n   * 1. [`"midiaccessgranted"`](#event:midiaccessgranted) event is triggered once the user has\n   * granted access to use MIDI.\n   * 2. [`"connected"`](#event:connected) events are triggered (for each available input and output)\n   * 3. [`"enabled"`](#event:enabled) event is triggered when WebMidi.js is fully ready\n   * 4. specified callback (if any) is executed\n   * 5. promise is resolved and fulfilled with the `WebMidi` object.\n   *\n   * **Important note**: starting with Chrome v77, a page using Web MIDI API must be hosted on a\n   * secure origin (`https://`, `localhost` or `file:///`) and the user will always be prompted to\n   * authorize the operation (no matter if the `sysex` option is `true` or not).\n   *\n   * ##### Example\n   * ```js\n   * // Enabling WebMidi and using the promise\n   * WebMidi.enable().then(() => {\n   *   console.log("WebMidi.js has been enabled!");\n   * })\n   * ```\n   *\n   * @param [options] {object}\n   *\n   * @param [options.callback] {function} A function to execute once the operation completes. This\n   * function will receive an `Error` object if enabling the Web MIDI API failed.\n   *\n   * @param [options.sysex=false] {boolean} Whether to enable MIDI system exclusive messages or not.\n   *\n   * @param [options.validation=true] {boolean} Whether to enable library-wide validation of method\n   * arguments and setter values. This is an advanced setting that should be used carefully. Setting\n   * [`validation`](#validation) to `false` improves performance but should only be done once the\n   * project has been thoroughly tested with [`validation`](#validation)  turned on.\n   *\n   * @param [options.software=false] {boolean} Whether to request access to software synthesizers on\n   * the host system. This is part of the spec but has not yet been implemented by most browsers as\n   * of April 2020.\n   *\n   * @param [options.requestMIDIAccessFunction] {function} A custom function to use to return\n   * the MIDIAccess object. This is useful if you want to use a polyfill for the Web MIDI API\n   * or if you want to use a custom implementation of the Web MIDI API - probably for testing\n   * purposes.\n   *\n   * @async\n   *\n   * @returns {Promise.<WebMidi>} The promise is fulfilled with the `WebMidi` object for\n   * chainability\n   *\n   * @throws {Error} The Web MIDI API is not supported in your environment.\n   * @throws {Error} Jazz-Plugin must be installed to use WebMIDIAPIShim.\n   */\n  async enable(e = {}, t = !1) {\n    if (o.isNode)\n      try {\n        window.navigator;\n      } catch {\n        let h = await Object.getPrototypeOf(async function() {\n        }).constructor(`\n        let jzz = await import("jzz");\n        return jzz.default;\n        `)();\n        global.navigator || (global.navigator = {}), Object.assign(global.navigator, h);\n      }\n    if (this.validation = e.validation !== !1, this.validation && (typeof e == "function" && (e = { callback: e, sysex: t }), t && (e.sysex = !0)), this.enabled)\n      return typeof e.callback == "function" && e.callback(), Promise.resolve();\n    const n = {\n      timestamp: this.time,\n      target: this,\n      type: "error",\n      error: void 0\n    }, r = {\n      timestamp: this.time,\n      target: this,\n      type: "midiaccessgranted"\n    }, s = {\n      timestamp: this.time,\n      target: this,\n      type: "enabled"\n    };\n    try {\n      typeof e.requestMIDIAccessFunction == "function" ? this.interface = await e.requestMIDIAccessFunction(\n        { sysex: e.sysex, software: e.software }\n      ) : this.interface = await navigator.requestMIDIAccess(\n        { sysex: e.sysex, software: e.software }\n      );\n    } catch (d) {\n      return n.error = d, this.emit("error", n), typeof e.callback == "function" && e.callback(d), Promise.reject(d);\n    }\n    this.emit("midiaccessgranted", r), this.interface.onstatechange = this._onInterfaceStateChange.bind(this);\n    try {\n      await this._updateInputsAndOutputs();\n    } catch (d) {\n      return n.error = d, this.emit("error", n), typeof e.callback == "function" && e.callback(d), Promise.reject(d);\n    }\n    return this.emit("enabled", s), typeof e.callback == "function" && e.callback(), Promise.resolve(this);\n  }\n  /**\n   * Completely disables **WebMidi.js** by unlinking the MIDI subsystem\'s interface and closing all\n   * [`Input`](Input) and [`Output`](Output) objects that may have been opened. This also means that\n   * listeners added to [`Input`](Input) objects, [`Output`](Output) objects or to `WebMidi` itself\n   * are also destroyed.\n   *\n   * @async\n   * @returns {Promise<Array>}\n   *\n   * @throws {Error} The Web MIDI API is not supported by your environment.\n   *\n   * @since 2.0.0\n   */\n  async disable() {\n    return this.interface && (this.interface.onstatechange = void 0), this._destroyInputsAndOutputs().then(() => {\n      navigator && typeof navigator.close == "function" && navigator.close(), this.interface = null;\n      let e = {\n        timestamp: this.time,\n        target: this,\n        type: "disabled"\n      };\n      this.emit("disabled", e), this.removeListener();\n    });\n  }\n  /**\n   * Returns the [`Input`](Input) object that matches the specified ID string or `false` if no\n   * matching input is found. As per the Web MIDI API specification, IDs are strings (not integers).\n   *\n   * Please note that IDs change from one host to another. For example, Chrome does not use the same\n   * kind of IDs as Jazz-Plugin.\n   *\n   * @param id {string} The ID string of the input. IDs can be viewed by looking at the\n   * [`WebMidi.inputs`](WebMidi#inputs) array. Even though they sometimes look like integers, IDs\n   * are strings.\n   * @param [options] {object}\n   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected input\n   *\n   * @returns {Input} An [`Input`](Input) object matching the specified ID string or `undefined`\n   * if no matching input can be found.\n   *\n   * @throws {Error} WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getInputById(e, t = { disconnected: !1 }) {\n    if (this.validation) {\n      if (!this.enabled) throw new Error("WebMidi is not enabled.");\n      if (!e) return;\n    }\n    if (t.disconnected) {\n      for (let n = 0; n < this._disconnectedInputs.length; n++)\n        if (this._disconnectedInputs[n].id === e.toString()) return this._disconnectedInputs[n];\n    } else\n      for (let n = 0; n < this.inputs.length; n++)\n        if (this.inputs[n].id === e.toString()) return this.inputs[n];\n  }\n  /**\n   * Returns the first [`Input`](Input) object whose name **contains** the specified string. Note\n   * that the port names change from one environment to another. For example, Chrome does not report\n   * input names in the same way as the Jazz-Plugin does.\n   *\n   * @param name {string} The non-empty string to look for within the name of MIDI inputs (such as\n   * those visible in the [inputs](WebMidi#inputs) array).\n   *\n   * @returns {Input} The [`Input`](Input) that was found or `undefined` if no input contained the\n   * specified name.\n   * @param [options] {object}\n   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected input\n   *\n   * @throws {Error} WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getInputByName(e, t = { disconnected: !1 }) {\n    if (this.validation) {\n      if (!this.enabled) throw new Error("WebMidi is not enabled.");\n      if (!e) return;\n      e = e.toString();\n    }\n    if (t.disconnected) {\n      for (let n = 0; n < this._disconnectedInputs.length; n++)\n        if (~this._disconnectedInputs[n].name.indexOf(e)) return this._disconnectedInputs[n];\n    } else\n      for (let n = 0; n < this.inputs.length; n++)\n        if (~this.inputs[n].name.indexOf(e)) return this.inputs[n];\n  }\n  /**\n   * Returns the first [`Output`](Output) object whose name **contains** the specified string. Note\n   * that the port names change from one environment to another. For example, Chrome does not report\n   * input names in the same way as the Jazz-Plugin does.\n   *\n   * @param name {string} The non-empty string to look for within the name of MIDI inputs (such as\n   * those visible in the [`outputs`](#outputs) array).\n   * @param [options] {object}\n   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected output\n   *\n   * @returns {Output} The [`Output`](Output) that was found or `undefined` if no output matched\n   * the specified name.\n   *\n   * @throws {Error} WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getOutputByName(e, t = { disconnected: !1 }) {\n    if (this.validation) {\n      if (!this.enabled) throw new Error("WebMidi is not enabled.");\n      if (!e) return;\n      e = e.toString();\n    }\n    if (t.disconnected) {\n      for (let n = 0; n < this._disconnectedOutputs.length; n++)\n        if (~this._disconnectedOutputs[n].name.indexOf(e)) return this._disconnectedOutputs[n];\n    } else\n      for (let n = 0; n < this.outputs.length; n++)\n        if (~this.outputs[n].name.indexOf(e)) return this.outputs[n];\n  }\n  /**\n   * Returns the [`Output`](Output) object that matches the specified ID string or `false` if no\n   * matching output is found. As per the Web MIDI API specification, IDs are strings (not\n   * integers).\n   *\n   * Please note that IDs change from one host to another. For example, Chrome does not use the same\n   * kind of IDs as Jazz-Plugin.\n   *\n   * @param id {string} The ID string of the port. IDs can be viewed by looking at the\n   * [`WebMidi.outputs`](WebMidi#outputs) array.\n   * @param [options] {object}\n   * @param [options.disconnected] {boolean} Whether to retrieve a disconnected output\n   *\n   * @returns {Output} An [`Output`](Output) object matching the specified ID string. If no\n   * matching output can be found, the method returns `undefined`.\n   *\n   * @throws {Error} WebMidi is not enabled.\n   *\n   * @since 2.0.0\n   */\n  getOutputById(e, t = { disconnected: !1 }) {\n    if (this.validation) {\n      if (!this.enabled) throw new Error("WebMidi is not enabled.");\n      if (!e) return;\n    }\n    if (t.disconnected) {\n      for (let n = 0; n < this._disconnectedOutputs.length; n++)\n        if (this._disconnectedOutputs[n].id === e.toString()) return this._disconnectedOutputs[n];\n    } else\n      for (let n = 0; n < this.outputs.length; n++)\n        if (this.outputs[n].id === e.toString()) return this.outputs[n];\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0.0, use Utilities.toNoteNumber() instead.\n   */\n  noteNameToNumber(e) {\n    return this.validation && console.warn(\n      "The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."\n    ), o.toNoteNumber(e, this.octaveOffset);\n  }\n  /**\n   * @private\n   * @deprecated since 3.0.0, use Utilities.getNoteDetails() instead.\n   */\n  getOctave(e) {\n    return this.validation && (console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"), e = parseInt(e)), !isNaN(e) && e >= 0 && e <= 127 ? o.getNoteDetails(o.offsetNumber(e, this.octaveOffset)).octave : !1;\n  }\n  /**\n   * @private\n   * @deprecated since 3.0.0, use Utilities.sanitizeChannels() instead.\n   */\n  sanitizeChannels(e) {\n    return this.validation && console.warn("The sanitizeChannels() method has been moved to the utilities class."), o.sanitizeChannels(e);\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0.0, use Utilities.sanitizeChannels() instead.\n   */\n  toMIDIChannels(e) {\n    return this.validation && console.warn(\n      "The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."\n    ), o.sanitizeChannels(e);\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0.0, use Utilities.guessNoteNumber() instead.\n   */\n  guessNoteNumber(e) {\n    return this.validation && console.warn(\n      "The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."\n    ), o.guessNoteNumber(e, this.octaveOffset);\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0.0, use Utilities.buildNoteArray() instead.\n   */\n  getValidNoteArray(e, t = {}) {\n    return this.validation && console.warn(\n      "The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"\n    ), o.buildNoteArray(e, t);\n  }\n  /**\n   * @private\n   * @deprecated since version 3.0.0, use Utilities.toTimestamp() instead.\n   */\n  convertToTimestamp(e) {\n    return this.validation && console.warn(\n      "The convertToTimestamp() method has been moved to Utilities.toTimestamp()."\n    ), o.toTimestamp(e);\n  }\n  /**\n   * @return {Promise<void>}\n   * @private\n   */\n  async _destroyInputsAndOutputs() {\n    let e = [];\n    return this.inputs.forEach((t) => e.push(t.destroy())), this.outputs.forEach((t) => e.push(t.destroy())), Promise.all(e).then(() => {\n      this._inputs = [], this._outputs = [];\n    });\n  }\n  /**\n   * @private\n   */\n  _onInterfaceStateChange(e) {\n    this._updateInputsAndOutputs();\n    let t = {\n      timestamp: e.timeStamp,\n      type: e.port.state,\n      target: this\n    };\n    if (e.port.state === "connected" && e.port.connection === "open") {\n      e.port.type === "output" ? t.port = this.getOutputById(e.port.id) : e.port.type === "input" && (t.port = this.getInputById(e.port.id)), this.emit(e.port.state, t);\n      const n = Object.assign({}, t);\n      n.type = "portschanged", this.emit(n.type, n);\n    } else if (e.port.state === "disconnected" && e.port.connection === "pending") {\n      e.port.type === "input" ? t.port = this.getInputById(e.port.id, { disconnected: !0 }) : e.port.type === "output" && (t.port = this.getOutputById(e.port.id, { disconnected: !0 })), this.emit(e.port.state, t);\n      const n = Object.assign({}, t);\n      n.type = "portschanged", this.emit(n.type, n);\n    }\n  }\n  /**\n   * @private\n   */\n  async _updateInputsAndOutputs() {\n    return Promise.all([\n      this._updateInputs(),\n      this._updateOutputs()\n    ]);\n  }\n  /**\n   * @private\n   */\n  async _updateInputs() {\n    if (!this.interface) return;\n    for (let t = this._inputs.length - 1; t >= 0; t--) {\n      const n = this._inputs[t];\n      Array.from(this.interface.inputs.values()).find((s) => s === n._midiInput) || (this._disconnectedInputs.push(n), this._inputs.splice(t, 1));\n    }\n    let e = [];\n    return this.interface.inputs.forEach((t) => {\n      if (!this._inputs.find((n) => n._midiInput === t)) {\n        let n = this._disconnectedInputs.find((r) => r._midiInput === t);\n        n || (n = new Z(t)), this._inputs.push(n), e.push(n.open());\n      }\n    }), Promise.all(e);\n  }\n  /**\n   * @private\n   */\n  async _updateOutputs() {\n    if (!this.interface) return;\n    for (let t = this._outputs.length - 1; t >= 0; t--) {\n      const n = this._outputs[t];\n      Array.from(this.interface.outputs.values()).find((s) => s === n._midiOutput) || (this._disconnectedOutputs.push(n), this._outputs.splice(t, 1));\n    }\n    let e = [];\n    return this.interface.outputs.forEach((t) => {\n      if (!this._outputs.find((n) => n._midiOutput === t)) {\n        let n = this._disconnectedOutputs.find((r) => r._midiOutput === t);\n        n || (n = new I(t)), this._outputs.push(n), e.push(n.open());\n      }\n    }), Promise.all(e);\n  }\n  // injectPluginMarkup(parent) {\n  //\n  //   // Silently ignore on Node.js\n  //   if (Utilities.isNode) return;\n  //\n  //   // Default to <body> if no parent is specified\n  //   if (!(parent instanceof Element) && !(parent instanceof HTMLDocument)) {\n  //     parent = document.body;\n  //   }\n  //\n  //   // IE10 needs this:\n  //   // <meta http-equiv="X-UA-Compatible" content="requiresActiveX=true"/>\n  //\n  //   // Create markup and add to parent\n  //   const obj = document.createElement("object");\n  //   obj.classid = "CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90"; // IE\n  //   if (!obj.isJazz) obj.type = "audio/x-jazz";                 // Standards-compliant\n  //   obj.style.visibility = "hidden";\n  //   obj.style.width = obj.style.height = "0px";\n  //   parent.appendChild(obj);\n  //\n  // }\n  /**\n   * Indicates whether access to the host\'s MIDI subsystem is active or not.\n   *\n   * @readonly\n   * @type {boolean}\n   */\n  get enabled() {\n    return this.interface !== null;\n  }\n  /**\n   * An array of all currently available MIDI inputs.\n   *\n   * @readonly\n   * @type {Input[]}\n   */\n  get inputs() {\n    return this._inputs;\n  }\n  /**\n   * @private\n   * @deprecated\n   */\n  get isNode() {\n    return this.validation && console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead."), o.isNode;\n  }\n  /**\n   * @private\n   * @deprecated\n   */\n  get isBrowser() {\n    return this.validation && console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead."), o.isBrowser;\n  }\n  /**\n   * An integer to offset the octave of notes received from external devices or sent to external\n   * devices.\n   *\n   * When a MIDI message comes in on an input channel the reported note name will be offset. For\n   * example, if the `octaveOffset` is set to `-1` and a [`"noteon"`](InputChannel#event:noteon)\n   * message with MIDI number 60 comes in, the note will be reported as C3 (instead of C4).\n   *\n   * By the same token, when [`OutputChannel.playNote()`](OutputChannel#playNote) is called, the\n   * MIDI note number being sent will be offset. If `octaveOffset` is set to `-1`, the MIDI note\n   * number sent will be 72 (instead of 60).\n   *\n   * @type {number}\n   *\n   * @since 2.1\n   */\n  get octaveOffset() {\n    return this._octaveOffset;\n  }\n  set octaveOffset(e) {\n    if (this.validation && (e = parseInt(e), isNaN(e)))\n      throw new TypeError("The \'octaveOffset\' property must be an integer.");\n    this._octaveOffset = e;\n  }\n  /**\n   * An array of all currently available MIDI outputs as [`Output`](Output) objects.\n   *\n   * @readonly\n   * @type {Output[]}\n   */\n  get outputs() {\n    return this._outputs;\n  }\n  /**\n   * Indicates whether the environment provides support for the Web MIDI API or not.\n   *\n   * **Note**: in environments that do not offer built-in MIDI support, this will report `true` if\n   * the\n   * [`navigator.requestMIDIAccess`](https://developer.mozilla.org/en-US/docs/Web/API/MIDIAccess)\n   * function is available. For example, if you have installed WebMIDIAPIShim.js but no plugin, this\n   * property will be `true` even though actual support might not be there.\n   *\n   * @readonly\n   * @type {boolean}\n   */\n  get supported() {\n    return typeof navigator < "u" && !!navigator.requestMIDIAccess;\n  }\n  /**\n   * Indicates whether MIDI system exclusive messages have been activated when WebMidi.js was\n   * enabled via the [`enable()`](#enable) method.\n   *\n   * @readonly\n   * @type boolean\n   */\n  get sysexEnabled() {\n    return !!(this.interface && this.interface.sysexEnabled);\n  }\n  /**\n   * The elapsed time, in milliseconds, since the time\n   * [origin](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp#The_time_origin).\n   * Said simply, it is the number of milliseconds that passed since the page was loaded. Being a\n   * floating-point number, it has sub-millisecond accuracy. According to the\n   * [documentation](https://developer.mozilla.org/en-US/docs/Web/API/DOMHighResTimeStamp), the\n   * time should be accurate to 5 s (microseconds). However, due to various constraints, the\n   * browser might only be accurate to one millisecond.\n   *\n   * Note: `WebMidi.time` is simply an alias to `performance.now()`.\n   *\n   * @type {DOMHighResTimeStamp}\n   * @readonly\n   */\n  get time() {\n    return performance.now();\n  }\n  /**\n   * The version of the library as a [semver](https://semver.org/) string.\n   *\n   * @readonly\n   * @type string\n   */\n  get version() {\n    return "3.1.12";\n  }\n  /**\n   * The flavour of the library. Can be one of:\n   *\n   * * `esm`: ECMAScript Module\n   * * `cjs`: CommonJS Module\n   * * `iife`: Immediately-Invoked Function Expression\n   *\n   * @readonly\n   * @type string\n   * @since 3.0.25\n   */\n  get flavour() {\n    return "esm";\n  }\n  /**\n   * @private\n   * @deprecated since 3.0.0. Use Enumerations.CHANNEL_EVENTS instead.\n   */\n  get CHANNEL_EVENTS() {\n    return this.validation && console.warn(\n      "The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."\n    ), i.CHANNEL_EVENTS;\n  }\n  /**\n   * @private\n   * @deprecated since 3.0.0. Use Enumerations.SYSTEM_MESSAGES instead.\n   */\n  get MIDI_SYSTEM_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.SYSTEM_MESSAGES."\n    ), i.SYSTEM_MESSAGES;\n  }\n  /**\n   * @private\n   * @deprecated since 3.0.0. Use Enumerations.CHANNEL_MODE_MESSAGES instead\n   */\n  get MIDI_CHANNEL_MODE_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.CHANNEL_MODE_MESSAGES."\n    ), i.CHANNEL_MODE_MESSAGES;\n  }\n  /**\n   * @private\n   * @deprecated since 3.0.0. Use Enumerations.CONTROL_CHANGE_MESSAGES instead.\n   */\n  get MIDI_CONTROL_CHANGE_MESSAGES() {\n    return this.validation && console.warn(\n      "The MIDI_CONTROL_CHANGE_MESSAGES enum has been replaced by the Enumerations.CONTROL_CHANGE_MESSAGES array."\n    ), i.MIDI_CONTROL_CHANGE_MESSAGES;\n  }\n  /**\n   * @deprecated since 3.0.0. Use Enumerations.REGISTERED_PARAMETERS instead.\n   * @private\n   */\n  get MIDI_REGISTERED_PARAMETER() {\n    return this.validation && console.warn(\n      "The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.REGISTERED_PARAMETERS."\n    ), i.REGISTERED_PARAMETERS;\n  }\n  /**\n   * @deprecated since 3.0.0.\n   * @private\n   */\n  get NOTES() {\n    return this.validation && console.warn("The NOTES enum has been deprecated."), ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];\n  }\n};\nconst l = new oe();\nl.constructor = null;\nconst le = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  Enumerations: i,\n  Forwarder: B,\n  Input: Z,\n  InputChannel: X,\n  Message: U,\n  Note: b,\n  Output: I,\n  OutputChannel: J,\n  Utilities: o,\n  WebMidi: l\n}, Symbol.toStringTag, { value: "Module" })), { WebMidi: c } = le;\nfunction de() {\n  return typeof navigator.requestMIDIAccess == "function";\n}\nfunction w(a) {\n  return a.map((e) => `\'${e.name}\'`).join(" | ");\n}\nfunction ee(a = {}) {\n  const { onReady: e, onConnected: t, onDisconnected: n, onEnabled: r } = a;\n  if (!c.enabled) {\n    if (!de())\n      throw new Error("Your Browser does not support WebMIDI.");\n    return c.addListener("connected", () => {\n      t?.(c);\n    }), c.addListener("enabled", () => {\n      r?.(c);\n    }), c.addListener("disconnected", (s) => {\n      n?.(c, s);\n    }), new Promise((s, d) => {\n      if (c.enabled) {\n        s(c);\n        return;\n      }\n      c.enable(\n        (h) => {\n          h && d(h), e?.(c), s(c);\n        },\n        { sysex: !0 }\n      );\n    });\n  }\n}\nfunction D(a, e) {\n  if (!e.length)\n    throw new Error(" No MIDI devices found. Connect a device or enable IAC Driver.");\n  if (typeof a == "number")\n    return e[a];\n  const t = (s) => e.find((d) => d.name.includes(s));\n  if (typeof a == "string")\n    return t(a);\n  const n = t("IAC"), r = n ?? e[0];\n  if (!r)\n    throw new Error(\n      ` MIDI device \'${r || ""}\' not found. Use one of ${w(e)}`\n    );\n  return n ?? e[0];\n}\ntypeof window < "u" && window.addEventListener("message", (a) => {\n  c?.enabled && a.data === "strudel-stop" && c.outputs.forEach((e) => e.sendStop());\n});\nconst y = /* @__PURE__ */ new Map();\nfunction te(a) {\n  return Object.fromEntries(\n    Object.entries(a).map(([e, t]) => (typeof t == "number" && (t = { ccn: t }), [(0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.B)(e), t]))\n  );\n}\nfunction ce(a, e = "") {\n  if (!a.startsWith("github:"))\n    throw new Error(\'expected "github:" at the start of pseudoUrl\');\n  let [t, n] = a.split("github:");\n  return n = n.endsWith("/") ? n.slice(0, -1) : n, n.split("/").length === 2 && (n += "/main"), `https://raw.githubusercontent.com/${n}/${e}`;\n}\nfunction ye(a) {\n  y.set("default", te(a));\n}\nlet v = {};\nasync function we(a) {\n  typeof a == "string" && (a.startsWith("github:") && (a = ce(a, "midimap.json")), v[a] || (v[a] = fetch(a).then((e) => e.json())), a = await v[a]), typeof a == "object" && Object.entries(a).forEach(([e, t]) => y.set(e, te(t)));\n}\nconst _e = /* @__PURE__ */ new Map();\nfunction he(a = 0, e = 0, t = 1, n = 1) {\n  if (e === t)\n    throw new Error("min and max cannot be the same value");\n  let r = (a - e) / (t - e);\n  return r = Math.min(1, Math.max(0, r)), Math.pow(r, n);\n}\nfunction fe(a, e) {\n  return Object.keys(e).filter((t) => !!a[(0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.B)(t)]).map((t) => {\n    const { ccn: n, min: r = 0, max: s = 1, exp: d = 1 } = a[t], h = he(e[t], r, s, d);\n    return { ccn: n, ccv: h };\n  });\n}\nfunction O(a, e, t, n, r) {\n  if (typeof e != "number" || e < 0 || e > 1)\n    throw new Error("expected ccv to be a number between 0 and 1");\n  if (!["string", "number"].includes(typeof a))\n    throw new Error("expected ccn to be a number or a string");\n  const s = Math.round(e * 127);\n  t.sendControlChange(a, s, n, { time: r });\n}\nfunction W(a, e, t, n) {\n  if (typeof a != "number" || a < 0 || a > 127)\n    throw new Error("expected progNum (program change) to be a number between 0 and 127");\n  e.sendProgramChange(a, t, { time: n });\n}\nfunction q(a, e, t, n) {\n  if (Array.isArray(a)) {\n    if (!a.every((r) => Number.isInteger(r) && r >= 0 && r <= 255))\n      throw new Error("all sysexid bytes must be integers between 0 and 255");\n  } else if (!Number.isInteger(a) || a < 0 || a > 255)\n    throw new Error("A:sysexid must be an number between 0 and 255 or an array of such integers");\n  if (!Array.isArray(e))\n    throw new Error("expected sysex to be an array of numbers (0-255)");\n  if (!e.every((r) => Number.isInteger(r) && r >= 0 && r <= 255))\n    throw new Error("all sysex bytes must be integers between 0 and 255");\n  t.sendSysex(a, e, { time: n });\n}\nfunction ue(a, e, t, n, r) {\n  if (Array.isArray(a)) {\n    if (!a.every((s) => Number.isInteger(s) && s >= 0 && s <= 255))\n      throw new Error("all nrpnn bytes must be integers between 0 and 255");\n  } else if (!Number.isInteger(e) || e < 0 || e > 255)\n    throw new Error("A:sysexid must be an number between 0 and 255 or an array of such integers");\n  t.sendNRPN(a, e, n, { time: r });\n}\nfunction me(a, e, t, n) {\n  if (typeof a != "number" || a < -1 || a > 1)\n    throw new Error("expected midibend to be a number between -1 and 1");\n  e.sendPitchBend(a, t, { time: n });\n}\nfunction Ee(a, e, t, n) {\n  if (typeof a != "number" || a < 0 || a > 1)\n    throw new Error("expected miditouch to be a number between 0 and 1");\n  e.sendChannelAftertouch(a, t, { time: n });\n}\nfunction pe(a, e, t, n, r, s) {\n  if (a == null || a === "")\n    throw new Error("note cannot be null or empty");\n  if (e != null && (typeof e != "number" || e < 0 || e > 1))\n    throw new Error("velocity must be a number between 0 and 1");\n  if (t != null && (typeof t != "number" || t < 0))\n    throw new Error("duration must be a positive number");\n  const d = typeof a == "number" ? a : (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.C)(a), h = new b(d, { attack: e, duration: t });\n  n.playNote(h, r, {\n    time: s\n  });\n}\n_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.P.prototype.midi = function(a, e = {}) {\n  if ((0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.v)(a))\n    throw new Error(\n      `.midi does not accept Pattern input for midiport. Make sure to pass device name with single quotes. Example: .midi(\'${c.outputs?.[0]?.name || "IAC Driver Bus 1"}\')`\n    );\n  if (typeof a == "object") {\n    const { port: n, isController: r = !1, ...s } = a;\n    e = {\n      isController: r,\n      ...s,\n      ...e\n      // Keep any options passed separately\n    }, a = n;\n  }\n  let t = {\n    // Default configuration values\n    isController: !1,\n    // Disable sending notes for midi controllers\n    latencyMs: 34,\n    // Default latency to get audio engine to line up in ms\n    noteOffsetMs: 10,\n    // Default note-off offset to prevent glitching in ms\n    midichannel: 1,\n    // Default MIDI channel\n    velocity: 0.9,\n    // Default velocity\n    gain: 1,\n    // Default gain\n    midimap: "default",\n    // Default MIDI map\n    midiport: a,\n    // Store the port in the config\n    ...e\n    // Override defaults with provided options\n  };\n  return ee({\n    onEnabled: ({ outputs: n }) => {\n      const r = D(t.midiport, n), s = n.filter((d) => d.name !== r.name);\n      (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.A)(\n        `Midi enabled! Using "${r.name}". ${s?.length ? `Also available: ${w(s)}` : ""}`\n      );\n    },\n    onDisconnected: ({ outputs: n }) => (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.A)(`Midi device disconnected! Available: ${w(n)}`)\n  }), this.onTrigger((n, r, s, d, h) => {\n    if (!c.enabled) {\n      (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.A)("Midi not enabled");\n      return;\n    }\n    r.ensureObjectValue();\n    const _ = t.latencyMs, u = `+${(0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.E)(h, s) + _}`;\n    let {\n      note: L,\n      nrpnn: P,\n      nrpv: x,\n      ccn: G,\n      ccv: H,\n      midichan: p = t.midichannel,\n      midicmd: m,\n      midibend: k,\n      miditouch: F,\n      polyTouch: be,\n      gain: ne = t.gain,\n      velocity: C = t.velocity,\n      progNum: V,\n      sysexid: z,\n      sysexdata: j,\n      midimap: S = t.midimap,\n      midiport: Y = t.midiport\n    } = r.value;\n    const f = D(Y, c.outputs);\n    if (!f) {\n      (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.A)(\n        `[midi] midiport "${Y}" not found! available: ${c.outputs.map((N) => `\'${N.name}\'`).join(", ")}`\n      );\n      return;\n    }\n    if (C = ne * C, y.has(S) ? fe(y.get(S), r.value).forEach(({ ccn: R, ccv: T }) => O(R, T, f, p, u)) : S !== "default" && (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.A)(`[midi] midimap "${S}" not found! Available maps: ${[...y.keys()].join(", ")}`), L !== void 0 && !t.isController) {\n      const N = r.duration.valueOf() / d * 1e3 - t.noteOffsetMs;\n      pe(L, C, N, f, p, u);\n    }\n    if (V !== void 0 && W(V, f, p, u), z !== void 0 && j !== void 0 && q(z, j, f, u), H !== void 0 && G !== void 0 && O(G, H, f, p, u), P !== void 0 && x !== void 0 && ue(P, x, f, p, u), k !== void 0 && me(k, f, p, u), F !== void 0 && Ee(F, f, p, u), r.whole.begin + 0 === 0 && f.sendStart({ time: u }), ["clock", "midiClock"].includes(m))\n      f.sendClock({ time: u });\n    else if (["start"].includes(m))\n      f.sendStart({ time: u });\n    else if (["stop"].includes(m))\n      f.sendStop({ time: u });\n    else if (["continue"].includes(m))\n      f.sendContinue({ time: u });\n    else if (Array.isArray(m)) {\n      if (m[0] === "progNum")\n        W(m[1], f, p, u);\n      else if (m[0] === "cc")\n        m.length === 2 && O(m[0], m[1] / 127, f, p, u);\n      else if (m[0] === "sysex" && m.length === 3) {\n        const [N, R, T] = m;\n        q(R, T, f, u);\n      }\n    }\n  });\n};\nlet M = {};\nconst A = {};\nasync function Se(a) {\n  if ((0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.v)(a))\n    throw new Error(\n      `midin: does not accept Pattern as input. Make sure to pass device name with single quotes. Example: midin(\'${c.outputs?.[0]?.name || "IAC Driver Bus 1"}\')`\n    );\n  const e = await ee(), t = D(a, c.inputs);\n  if (!t)\n    throw new Error(\n      `midiin: device "${a}" not found.. connected devices: ${w(c.inputs)}`\n    );\n  if (e) {\n    const r = c.inputs.filter((s) => s.name !== t.name);\n    (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.A)(\n      `Midi enabled! Using "${t.name}". ${r?.length ? `Also available: ${w(r)}` : ""}`\n    ), A[a] = {};\n  }\n  const n = (r) => (0,_index_DfdLyHnT_js__WEBPACK_IMPORTED_MODULE_0__.G)(() => A[a][r] || 0);\n  return M[a] && t.removeListener("midimessage", M[a]), M[a] = (r) => {\n    const s = r.dataBytes[0], d = r.dataBytes[1];\n    A[a] && (A[a][s] = d / 127);\n  }, t.addListener("midimessage", M[a]), n;\n}\n\n\n\n//# sourceURL=webpack://frontend/../node_modules/@strudel/repl/dist/index-D1GL2meg.js?')}}]);